(this["webpackJsonpos-notes"]=this["webpackJsonpos-notes"]||[]).push([[0],{20:function(e,l,t){e.exports=t(33)},32:function(e,l,t){},33:function(e,l,t){"use strict";t.r(l);var a=t(0),n=t.n(a),r=t(9),i=t.n(r),c=(t(25),t(10)),s=t(11),o=t(15),u=t(13),m=t(8),d=t(18),E=function(e){Object(o.a)(t,e);var l=Object(u.a)(t);function t(){var e;Object(c.a)(this,t);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=l.call.apply(l,[this].concat(n))).state={navExpanded:!1},e}return Object(s.a)(t,[{key:"render",value:function(){var e=this,l={backgroundColor:"rgb(156, 220, 164)"},t={color:"white",fontSize:"28px",fontFamily:"'Merienda One', cursive"};return this.props.showNav?n.a.createElement(m.a,{collapseOnSelect:!0,style:l,expand:"lg"},n.a.createElement(m.a.Brand,{style:t,href:"https://leonatwork.github.io/os-notes/"},"OS Notes"),n.a.createElement(m.a.Toggle,{"aria-controls":"basic-navbar-nav"}),n.a.createElement(m.a.Collapse,{id:"basic-navbar-nav"},n.a.createElement(d.a,{className:"mr-auto"},this.props.notes.map((function(l){var t="list-group-item";return l.id===e.props.activeNoteID&&(t+=" active-me"),n.a.createElement(d.a.Link,{key:l.id,href:"#"+l.id,className:t,onClick:function(){return e.props.handleClick(l.id)},style:{cursor:"pointer",textAlign:"center"}},l.title)}))))):n.a.createElement(m.a,{expand:"lg",style:l},n.a.createElement(m.a.Brand,{href:"https://leonatwork.github.io/os-notes/",style:t},"OS Notes"))}}]),t}(a.Component),h=function(e){var l=e.notes,t=e.activeNoteID,a=e.handleClick;return n.a.createElement("ul",{className:"list-group list-group-flush"},l.map((function(e){var l="list-group-item";return e.id===t&&(l+=" active"),n.a.createElement("li",{key:e.id,className:l,onClick:function(){return a(e.id)},style:{cursor:"pointer"}},e.title)})))},p=function(e){var l=e.note;return n.a.createElement(n.a.Fragment,null,l)},b=[{id:0,title:"Introduction",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Introduction"),n.a.createElement("hr",null),n.a.createElement("b",null,"Operating System"),n.a.createElement("ul",null,n.a.createElement("li",null,"System software that acts as an interface between user and hardware."),n.a.createElement("li",null,"OS manages computer hardware (controls and coordinates hardware among various programs and users)"),n.a.createElement("li",null,"Provides environment within which other programs can work")),n.a.createElement("b",null,"Other than kernel there are two types of softwares:"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"System SW :")," associated with OS but not part of the kernel"),n.a.createElement("li",null,n.a.createElement("b",null,"Application SW :")," includes all programs not associated with OS")),n.a.createElement("b",null,"Goals"),n.a.createElement("ul",null,n.a.createElement("li",null,"User friendly"),n.a.createElement("li",null,"Efficiency")),n.a.createElement("b",null,"Functions of OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Process management"),n.a.createElement("li",null,"Memory management"),n.a.createElement("li",null,"I/O device management"),n.a.createElement("li",null,"File management"),n.a.createElement("li",null,"Network management"),n.a.createElement("li",null,"Security and protection")),n.a.createElement("b",null,"Booting :")," starting the computer by loading the kernel",n.a.createElement("ul",null,n.a.createElement("li",null,"Initial program or bootstrap program runs at boot time. This program should be simple"),n.a.createElement("li",null,"It is stored in ROM or EEPROM and is known as firmware within the computer hardware"),n.a.createElement("li",null,"It initializes all aspects of system"),n.a.createElement("li",null,"Bootstrap must know how to load the OS. For this bootstrap must locate and load the OS kernel into memory")),n.a.createElement("b",null,"Interrupts"),n.a.createElement("ul",null,n.a.createElement("li",null,"Occurrence of an event is signaled by an interrupt from either hardware or software"),n.a.createElement("li",null,"Modern OSs are interrupt driven"),n.a.createElement("li",null,"HW trigger an interrupt by sending a signal to CPU"),n.a.createElement("li",null,"SW trigger an interrupt by executing a special operation called system call or monitor call"),n.a.createElement("li",null,"Number of interrupts are predefined. A table of pointers to interrupt routine is used to increase speed"),n.a.createElement("li",null,"This table is stored in low memory"),n.a.createElement("li",null,"Table keeps address of ISR for various devices. This array or interrupt vector is indexed by a unique device number. This number is provided with the request"),"Trap is a SW generated interrupt caused by an error/request from the program"),n.a.createElement("p",null,"CPU is connected to device via device controller. CPU and device controller can execute concurrently competing for memory cycles. Memory controller synchronizes access to memory"),n.a.createElement("b",null,"Storage structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"RAM (Main Memory)"),n.a.createElement("li",null,"Programs execute from Main memory"),n.a.createElement("li",null,"Use load and store operation"),n.a.createElement("li",null,"Load : main memory to internal registers"),n.a.createElement("li",null,"Store : internal registers to main memory"),n.a.createElement("li",null,"Instruction execution cycle (von Neumann Architecture) Fetch -",">"," ","Decode -",">"," Execute")),n.a.createElement("b",null,"Caching :")," copying information to faster storage system temporarily.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Storage hierarchy : "),"register(CMOS) -",">"," cache(SRAM) -",">"," main memory(DRAM) -",">"," disk storage/secondary memory(Magnetic disk)",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Virtual memory :")," a technique in which a program larger than size of main memory can be executed",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"I/O structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each device controller is incharge of specific kind of device"),n.a.createElement("li",null,"Device controller have buffer storage and set of special purpose registers"),n.a.createElement("ul",null,n.a.createElement("li",null,"I/O interrupts",n.a.createElement("ul",null,n.a.createElement("li",null,"Starting IO operations",n.a.createElement("ul",null,n.a.createElement("li",null,"CPU loads appropriate registers in device controller based on which dc takes action"),n.a.createElement("li",null,"Once complete the dc lets it known to CPU by triggering an interrupt"))))),n.a.createElement("li",null,"Synchronous IO",n.a.createElement("ul",null,n.a.createElement("li",null,"Control returned to IO process at IO completion"),n.a.createElement("li",null,"Till then process is moved to waiting phase"))),n.a.createElement("li",null,"Asynchronous IO",n.a.createElement("ul",null,n.a.createElement("li",null,"Control returned to IO process without waiting for IO completion"),n.a.createElement("li",null,"Device status table is used to keep track of IO devices. Table entry tells (device's type, address and state)"),n.a.createElement("li",null,"If other process requests the busy device then it is put in wait queue"),n.a.createElement("li",null,"On completion interrupt is triggered and table is updated"))))),n.a.createElement("b",null,"DMA structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"Used for high speed IO devices"),n.a.createElement("li",null,"Device controller set DMA controller registers to use appropriate source and destination addresses"),n.a.createElement("li",null,"OS finds a buffer for transfer"),n.a.createElement("li",null,"The device controller transfers a block of data directly to/from its own buffer storage to memory without CPU intervention."),n.a.createElement("li",null,"CPU can perform other tasks during this"),n.a.createElement("li",null,"Once transfer is complete DMA controller interrupts the CPU")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Computer System Architecture"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Single processor system :")," 1 CPU"),n.a.createElement("li",null,n.a.createElement("b",null,"Multi processor system :")," Multiple processors sharing resources like bus, clock, memory, peripherals... Adv is graceful degradation - incase of failure some system available to respond, but some slow down occurs.",n.a.createElement("ul",null,n.a.createElement("li",null,"Tandem system : 2 identical processors (Primary+Backup) if failure backup activated"),n.a.createElement("li",null,"SMP (Symmetric Multiprocessing system) - each processor runs identical copy of OS"),n.a.createElement("li",null,"Asymmetric MP - each system assigned specific task by master"),n.a.createElement("li",null,"Cluster systems : multiple CPU on different systems coupled together. Adv...high availability")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Types of OS"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Batch processing OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Jobs with similar needs are batched together and executed through processor as a group"),n.a.createElement("li",null,"No memory hierarchy only one memory and os is present it it the whole time"),n.a.createElement("li",null,"One cpu"),n.a.createElement("li",null,"One operator who groups the job into batches"),n.a.createElement("li",null,"Slow"),n.a.createElement("li",null,"Inefficient"),n.a.createElement("li",null,"Oldest"),n.a.createElement("li",null,"Better than previous design as grouping of jobs removed the time needed for loading compiler"))),n.a.createElement("li",null,n.a.createElement("b",null,"Spooling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Simultaneous peripheral operations online"),n.a.createElement("li",null,"Additional disk memory is introduced"),n.a.createElement("li",null,"Peripheral devices interact with disk directly and not cpu"),n.a.createElement("li",null,"Cpu only deals with main memory which in turn deals with disk"),n.a.createElement("li",null,"Cpu utilization is improved"),n.a.createElement("li",null,"Multiple devices can interact with disk simultaneously"),n.a.createElement("li",null,"Interactive processes possible"),n.a.createElement("li",null,"But dis adv is it is uniprogramming ie. cpu waits if process needs for some io"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multiprogramming OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Goal is max cpu utilization"),n.a.createElement("li",null,"Cpu doesn't wait if process waits for io, it executes another ready process available in main memory"),n.a.createElement("li",null,"Context switch between processes happens"),n.a.createElement("li",null,"More complex management/fragmentation issues/paging required"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multi tasking / time sharing / fair share / multiprogramming with round robin"),n.a.createElement("ul",null,n.a.createElement("li",null,"Multitasking is multiprogramming with time sharing"),n.a.createElement("li",null,"Only one cpu, context switch between processes happen so fast that it appears as if it is running simultaneously"),n.a.createElement("li",null,"High response time"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multiprocessing OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"2 or more CPUs in a single system, sharing memory, io devices and system buses"),n.a.createElement("li",null,"Truly parallel"),n.a.createElement("li",null,"2 kinds of architecture",n.a.createElement("ul",null,n.a.createElement("li",null,"Symmetric : all CPU same, managed by a single OS"),n.a.createElement("li",null,"Asymmetric : master slave"))),n.a.createElement("li",null,"Increased throughput and reliability")))))},{id:1,title:"Process Scheduling",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Process Scheduling"),n.a.createElement("hr",null),n.a.createElement("b",null,"Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Task of selecting a process from ready queue and allocating it to CPU"),n.a.createElement("li",null,"Records in the queue are generally the PCBs"),n.a.createElement("li",null,"CPU is allocated to the selected process by dispatcher")),n.a.createElement("b",null,"Process"),n.a.createElement("ul",null,n.a.createElement("li",null,"CPU bound"),n.a.createElement("li",null,"IO bound")),n.a.createElement("b",null,"Job scheduling : "),"which job to bring into memory",n.a.createElement("br",null),n.a.createElement("b",null,"CPU scheduling : "),"which job to run if several jobs are ready",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("p",null,"Process execution = CPU burst + I/O burst"),n.a.createElement("b",null,"Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Non preemptive / cooperative"),n.a.createElement("li",null,"Preemptive")),n.a.createElement("p",null,"Dispatcher is the module that gives of the CPU to the process selected by the short-term scheduler"),n.a.createElement("b",null,"Dispatcher functions"),n.a.createElement("ul",null,n.a.createElement("li",null,"Switching context"),n.a.createElement("li",null,"Switching user mode"),n.a.createElement("li",null,"Jumping to proper location in the user program to restart that program")),"Dispatcher should be extremely fast because it called every time a context switch occurs",n.a.createElement("br",null),n.a.createElement("b",null,"Dispatch latency :")," time it take for dispatcher to stop one process and start another",n.a.createElement("hr",null),n.a.createElement("h4",null,"Scheduling criteria"),n.a.createElement("ul",null,n.a.createElement("li",null,"CPU utilization"),n.a.createElement("li",null,"Throughput"),n.a.createElement("li",null,"Turn around time"),n.a.createElement("li",null,"Waiting time"),n.a.createElement("li",null,"Response time")),n.a.createElement("b",null,"Measurements"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Burst time (BT):")," time the process requires for running on CPU."),n.a.createElement("li",null,n.a.createElement("b",null,"Waiting time (WT):")," time spent by a process in ready state waiting for CPU."),n.a.createElement("li",null,n.a.createElement("b",null,"Arrival time (AT):")," time at which process arrives in ready state."),n.a.createElement("li",null,n.a.createElement("b",null,"Exit time (ET):")," when process completed its execution and exits the system."),n.a.createElement("li",null,n.a.createElement("b",null,"Turn around time (TAT):")," total time taken by a process in CPU (process submission to completion)."),n.a.createElement("li",null,n.a.createElement("b",null,"Response time :")," time between a process enters the ready queue and get scheduled on the CPU for the first time.")),n.a.createElement("p",null,"TAT = ET - AT = WT + BT"),n.a.createElement("b",null,"CPU scheduling evaluation criteria"),n.a.createElement("ul",null,n.a.createElement("li",null,"Average waiting time"),n.a.createElement("li",null,"Average response time"),n.a.createElement("li",null,"CPU utilization")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Algorithms"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"FCFS (non-preemptive)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Low throughput"),n.a.createElement("li",null,n.a.createElement("b",null,"Convoy effect :")," smaller process have to wait for long time for bigger process to release CPU"),n.a.createElement("li",null,n.a.createElement("b",null,"Advantage :")," simple and easy to use/understand. must be used for background process where execution is not urgent"),n.a.createElement("li",null,n.a.createElement("b",null,"Disadvantage :")," convoy effect, normally higher average waiting time, no consideration of priority or burst time."),n.a.createElement("li",null,"Should not be used for interactive system"),n.a.createElement("li",null,"No starvation here, as processor is unbiased"))),n.a.createElement("li",null,n.a.createElement("b",null,"SJF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Both preemptive SRTF and non-preemptive SJF"),n.a.createElement("li",null,"SRTF is optimal as it guarantees minimum average waiting time"),n.a.createElement("li",null,"Better average response time than FCFS"),n.a.createElement("li",null,"Cannot be implemented as we dont know burst time of a process"),n.a.createElement("li",null,"Starvation of larger burst time process and higher response time (Highest response ratio next - modification of SJF to solve this)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Priority Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Both preemptive and non-preemptive"),n.a.createElement("li",null,"How priority defined:",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Internally defined : "),"use some measurable quantity to compute the priority. Eg. time limits, memory requirements, no. of open files."),n.a.createElement("li",null,n.a.createElement("b",null,"Externally defined : "),"set by criteria that are external to the OS. Eg. by user."))),n.a.createElement("li",null,"Problem of starvation : low priority process never get access of CPU"),n.a.createElement("li",null,"Solution: Aging - increasing the priority of the process that waits in the system for longer time"))),n.a.createElement("li",null,n.a.createElement("b",null,"Round Robin"),n.a.createElement("ul",null,n.a.createElement("li",null,"Designed specially for time sharing systems"),n.a.createElement("li",null,"Like FCFS with preemption"),n.a.createElement("li",null,"Time quantum/time slice (generally 10 - 100ms)"),n.a.createElement("li",null,"Ready queue is treated as a circular queue"),n.a.createElement("li",null,"In RR we need to keep in mind the time for context switching"),n.a.createElement("li",null,"If time quantum is large then it will be like FCFS"),n.a.createElement("li",null,"If time quantum is very small (compared to context switch time) then overhead"),n.a.createElement("li",null,"Time quantum must be large with respect to context switch time"),n.a.createElement("li",null,"Has higher TAT compared to SJF but better response"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multilevel Queue Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Ready queue is partitioned into several separate queues"),n.a.createElement("li",null,"Processes are permanently assigned to one queue based on size, priority or process type."),n.a.createElement("li",null,"Each queue has its own scheduling"),n.a.createElement("li",null,"There must be scheduling among queues also i.e each queue gets a certain amount of CPU time and within that time it executes its processes."),n.a.createElement("li",null,"Scheduling between queues are mostly implemented as fixed priority preemptive scheduling (in fixed priority scheduling it will first cater to the foreground process and then serve background process)."),n.a.createElement("li",null,"Starvation possible"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multilevel Feedback Queue"),n.a.createElement("ul",null,n.a.createElement("li",null,"Processes may move between queues"),n.a.createElement("li",null,"Processes with different CPU-burst characteristics are now seperated"),n.a.createElement("li",null,"If process uses too much CPU time it is pushed to lower priority queue"),n.a.createElement("li",null,"If process waits too long in lower priority queue, it is moved to higher priority queue (aging prevents starvation)")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Thread Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"OS schedules the kernel level threads"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Local scheduling :")," thread library decides which thread to put onto an available light weight process."),n.a.createElement("li",null,n.a.createElement("b",null,"Global scheduling :")," kernel decides which kernel thread to run exist."))),n.a.createElement("b",null,"Contention scope"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Process contention scope : "),"On systems with many to many or many to one models, the thread library schedules user level threads to run on available light weight processes"),n.a.createElement("li",null,n.a.createElement("b",null,"System contention scope : "),"Process of deciding which kernel thread to run on CPU")),n.a.createElement("b",null,"Multiple processor scheduling (MPS)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Multiple CPUs available, more complex"),n.a.createElement("li",null,"Homogeneous processor : each process maintains its own private queue of processes or threads"),n.a.createElement("li",null,"Load balancing to improve performance may be done"),n.a.createElement("li",null,"Asymmetric multiprocessing (master-slave)")),n.a.createElement("b",null,"Approaches to MPS"),n.a.createElement("ul",null,n.a.createElement("li",null,"We assume processors are homogeneous and have UMA-uniform memory access"),n.a.createElement("li",null,"Load sharing can occur with a common ready queue",n.a.createElement("ul",null,n.a.createElement("li",null,"Each processor is self scheduling and selects a process from the common queue"),n.a.createElement("li",null,"One processor is appointed as scheduler (master-slave)"))),n.a.createElement("li",null,"Asymmetric multiprocessing is easier than SMP because only one machine can access the data"),n.a.createElement("li",null,"But bottleneck may happen as only one is scheduling"),n.a.createElement("li",null,"Nowaday symmetric is more used")),n.a.createElement("b",null,"Processor affinity :")," migration of a process to another processor is avoided because of the cost of invalidating the process and repopulating the processor cache.",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Soft affinity :")," here OS tries to keep a process on one processor, but cannot guarantee that it will happen."),n.a.createElement("li",null,n.a.createElement("b",null,"Hard affinity :")," when OS can make a process not to migrate to other processors.")),n.a.createElement("b",null,"Load balancing : "),"attempts to keep load evenly distributed across all processors in SMP system.",n.a.createElement("br",null),"Migration approaches",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Push migration :"),"load on each processors are checked and then distributed evenly in case of any imbalance"),n.a.createElement("li",null,n.a.createElement("b",null,"Pull migration : ")," an idle processor pulls a waiting task from a busy processor")),n.a.createElement("p",null,"Multicore processors have very complicated scheduling issue"))},{id:2,title:"System Calls",content:n.a.createElement("div",null,n.a.createElement("h1",null,"System Calls"),n.a.createElement("hr",null),n.a.createElement("ul",null,n.a.createElement("li",null,"Provides an interface to the services provided by the OS"),n.a.createElement("li",null,"Application programmer uses API, the API makes system calls on behalf of programmer"),n.a.createElement("li",null,"When a call is made, the user mode is switched to kernel mode, then the address of the implementation of that called function is fetched from a look up table and is executed"),n.a.createElement("li",null,"Methods to pass parameters:",n.a.createElement("ol",null,n.a.createElement("li",null,"Using registers"),n.a.createElement("li",null,"Via registers storing address to a block or table in memory holding parameters"),n.a.createElement("li",null,"Via stack (parameters are pushed and popped)")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Types of system calls"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Process control"),n.a.createElement("ul",null,n.a.createElement("li",null,"Program may end normally or abort abnormally"),n.a.createElement("li",null,"Program needs to loaded into main memory and transferred back once the job is done"),n.a.createElement("li",null,"Creating or terminating processes"),n.a.createElement("li",null,"Wait for other process to release resource, signal waiting processes that resource is now free"),n.a.createElement("li",null,"Set or get process attributes"),n.a.createElement("li",null,"Allocate or free memory"),n.a.createElement("li",null,"For above tasks related to processes, system calls are required"))),n.a.createElement("li",null,n.a.createElement("b",null,"File manipulation"),n.a.createElement("ul",null,n.a.createElement("li",null,"create, delete, open, close, update files"),n.a.createElement("li",null,"For above tasks related to files, system calls are required"))),n.a.createElement("li",null,n.a.createElement("b",null,"Device manipulation"),n.a.createElement("ul",null,n.a.createElement("li",null,"Giving access to resource"),n.a.createElement("li",null,"Handling concurrent access to a resource"),n.a.createElement("li",null,"Deallocating resources once the work is done"),n.a.createElement("li",null,"Request, release, attach, detach device"),n.a.createElement("li",null,"get, set device attribute"),n.a.createElement("li",null,"For above tasks related to devices, system calls are required"))),n.a.createElement("li",null,n.a.createElement("b",null,"Information maintenance"),n.a.createElement("ul",null,n.a.createElement("li",null,"Transfer info from user program to OS"),n.a.createElement("li",null,"get, set time,date,file,process,device attributes"),n.a.createElement("li",null,"For above tasks related to information, system calls are required"))),n.a.createElement("li",null,n.a.createElement("b",null,"Communication"),n.a.createElement("ul",null,n.a.createElement("li",null,"2 models for inter process communication",n.a.createElement("ol",null,n.a.createElement("li",null,"Message passing",n.a.createElement("ul",null,n.a.createElement("li",null,"Useful when small amount of data"),n.a.createElement("li",null,"Easier to implement"))),n.a.createElement("li",null,"Shared memory",n.a.createElement("ul",null,n.a.createElement("li",null,"Great speed"),n.a.createElement("li",null,"Protection and synchronization problem for shared area access"))))))),n.a.createElement("li",null,n.a.createElement("b",null,"Protection"),n.a.createElement("ul",null,n.a.createElement("li",null,"Mechanism for controlling resources"),n.a.createElement("li",null,"Specially when connected over a network")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Dual mode operation"),n.a.createElement("ul",null,n.a.createElement("li",null,"User mode & kernel/monitor mode"),n.a.createElement("li",null,"Mode bit 0 : task executed on behalf of OS"),n.a.createElement("li",null,"Mode bit 1 : task executed on behalf of user"),n.a.createElement("li",null,"Dual mode protects errant access to privileged locations which may harm the systems integrity."),n.a.createElement("li",null,"Privileged instruction can only be executed in monitor mode.")))},{id:3,title:"Designing OS",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Designing OS"),n.a.createElement("hr",null),n.a.createElement("ul",null,n.a.createElement("li",null,"No ideal solution exists"),n.a.createElement("li",null,"Depends on requirements (like real time, large scale, scientific)"),n.a.createElement("li",null,"User goals : fast,reliable, easy to use"),n.a.createElement("li",null,"System goal : easy to design,maintain and implement, error free"),n.a.createElement("li",null,"Design goals: convenience, reliable, fast, flexible and efficient")),n.a.createElement("p",null,n.a.createElement("b",null,"Policy : "),"determines what is to be done",n.a.createElement("br",null),n.a.createElement("b",null,"Mechanism : "),"determines how it is to be done"),n.a.createElement("p",null,"Earlier OS was mostly implemented in machine language (adv. less storage and fast OS). But now we use high level languages like C/C++ (adv. fast to develop but slow OS and inc. storage)"),n.a.createElement("hr",null),n.a.createElement("h4",null,"Structures of design"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Simple"),n.a.createElement("ul",null,n.a.createElement("li",null,"MS-DOS, UNIX initially"))),n.a.createElement("li",null,n.a.createElement("b",null,"Layered (modularity)"),n.a.createElement("ul",null,n.a.createElement("li",null,"n layers from hardware to the UI"))),n.a.createElement("li",null,n.a.createElement("b",null,"Microkernel"),n.a.createElement("ul",null,n.a.createElement("li",null,"Unnecessary features are removed from kernel and made into system and user programs"),n.a.createElement("li",null,"Smaller kernel size"),n.a.createElement("li",null,"Ease of extending OS services by adding to user programs"))),n.a.createElement("li",null,n.a.createElement("b",null,"Modules"),n.a.createElement("ul",null,n.a.createElement("li",null,"Kernel modules implemented"),n.a.createElement("li",null,"OO approach"),n.a.createElement("li",null,"Each core component is separate and talks with others using interfaces"))),n.a.createElement("li",null,n.a.createElement("b",null,"Virtual machine"),n.a.createElement("ul",null,n.a.createElement("li",null,"VM is an isolated computing environment created by abstracting resources from a physical machine."),n.a.createElement("li",null,"Creates illusion of multiple processors but resources are actually shared."),n.a.createElement("li",null,n.a.createElement("b",null,"Normal structure"),n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"150px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"Processes")),n.a.createElement("tr",null,n.a.createElement("td",null,"Kernel")),n.a.createElement("tr",null,n.a.createElement("td",null,"Hardware"))))),n.a.createElement("li",null,n.a.createElement("b",null,"VM structure"),n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"260px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"Processes"),n.a.createElement("td",null,"Processes"),n.a.createElement("td",null,"Processes")),n.a.createElement("tr",null,n.a.createElement("td",null,"Kernel"),n.a.createElement("td",null,"Kernel"),n.a.createElement("td",null,"Kernel")),n.a.createElement("tr",null,n.a.createElement("td",null,"VM 1"),n.a.createElement("td",null,"VM 2"),n.a.createElement("td",null,"VM 3")),n.a.createElement("tr",null,n.a.createElement("td",{colSpan:"3"},"VM implementation")),n.a.createElement("tr",null,n.a.createElement("td",null,"Hardware"),n.a.createElement("td",null,"Hardware"),n.a.createElement("td",null,"Hardware")))))))))},{id:4,title:"Process Management",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Process Management"),n.a.createElement("hr",null),n.a.createElement("b",null,"Program : "),"passive entity",n.a.createElement("br",null),n.a.createElement("b",null,"Process : "),"active entity",n.a.createElement("br",null),n.a.createElement("br",null),"Single threaded process has one program counter.",n.a.createElement("br",null),"Multi threaded process has one program counter per thread.",n.a.createElement("br",null),"Processes run concurrently by multiplexing the CPU",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"OS is responsible for :"),n.a.createElement("ul",null,n.a.createElement("li",null,"Process scheduling"),n.a.createElement("li",null,"Process creation and termination"),n.a.createElement("li",null,"Suspending and resuming"),n.a.createElement("li",null,"IPC"),n.a.createElement("li",null,"Process synchronization"),n.a.createElement("li",null,"Deadlock prevention")),"Process is the unit of work in most systems",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Threads"),n.a.createElement("ul",null,n.a.createElement("li",null,"They are lightweight processes"),n.a.createElement("li",null,"Each thread of a process has its own resources but they share some resources also.")),"A process include",n.a.createElement("ul",null,n.a.createElement("li",null,"Program counter"),n.a.createElement("li",null,"Stack"),n.a.createElement("li",null,"Data section")),n.a.createElement("b",null,"Process states"),n.a.createElement("ul",null,n.a.createElement("li",null,"New"),n.a.createElement("li",null,"Running"),n.a.createElement("li",null,"Waiting"),n.a.createElement("li",null,"Ready"),n.a.createElement("li",null,"Terminated")),"Scheduler Dispatch moves process from ready to running state",n.a.createElement("hr",null),n.a.createElement("h4",null,"Process Control Block (PCB)"),"PCB contains Information about",n.a.createElement("ul",null,n.a.createElement("li",null,"Process state"),n.a.createElement("li",null,"Program counter"),n.a.createElement("li",null,"CPU registers")),n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"150px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"Process State")),n.a.createElement("tr",null,n.a.createElement("td",null,"Process Number")),n.a.createElement("tr",null,n.a.createElement("td",null,"Program Counter")),n.a.createElement("tr",null,n.a.createElement("td",null,"Register")),n.a.createElement("tr",null,n.a.createElement("td",null,"Memory limits")),n.a.createElement("tr",null,n.a.createElement("td",null,"List of open files")),n.a.createElement("tr",null,n.a.createElement("td",null,"etc ...")))),"A process migrated between various queues",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Scheduling queues"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Job queue :")," as process enters a system they are put here",n.a.createElement("b",null,"Ready queue :")," processes in memory waiting for execution A ready queue header contains pointers to the first and last PCBs in the list, each PCBs of the list has a pointer to the next PCB",n.a.createElement("b",null,"Device queue :")," List of processes waiting for an I/O device")),"A process in execution can make",n.a.createElement("ul",null,n.a.createElement("li",null,"I/O request and would be out into the device queue"),n.a.createElement("li",null,"A sub-process and wait for its termination"),n.a.createElement("li",null,"Interrupted and go back to the ready queue")),n.a.createElement("b",null,"Scheduler"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Long term scheduler / Job scheduler"),n.a.createElement("ul",null,n.a.createElement("li",null,"Selects processes from pool (disk, secondary memory) and brings it into the main memory for execution"))),n.a.createElement("li",null,n.a.createElement("b",null,"Short term scheduler / CPU scheduler"),n.a.createElement("ul",null,n.a.createElement("li",null,"Selects a process among set of ready to execute processes and allocate CPU to it The main difference is in frequency of execution. (short-term = more frequent)")))),"Degree of multiprogramming (number of processes in main memory) It is controlled by long term scheduler",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"I/O bound processes :")," spends more time on I/O",n.a.createElement("br",null),n.a.createElement("b",null,"CPU bound processes :")," spends more time on doing computation",n.a.createElement("br",null),"Long term scheduler should select processes having good mix of these two",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Context switch"),n.a.createElement("ul",null,n.a.createElement("li",null,"Saving the state of the old process and switching to another process"),n.a.createElement("li",null,"Context of process is represented by its PCB")),n.a.createElement("b",null,"UNIX"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"fork :")," system call creates a new process",n.a.createElement("b",null,"exec :")," system call used after a fork to replace the process' memory space with a new program")),"Independent process (unaffected by others) vs Cooperative process (affected by others)",n.a.createElement("hr",null),n.a.createElement("h4",null,"Inter Process Communication (IPC)"),n.a.createElement("b",null,"Message passing"),n.a.createElement("ul",null,n.a.createElement("li",null,"ProcA -",">"," Kernel -",">"," ProcB"),n.a.createElement("li",null,"Passing msgs without having a shared data"),n.a.createElement("li",null,"Messages can be fixed or variable size"),n.a.createElement("li",null,"Send() and receive() primitives should be provided"),n.a.createElement("li",null,"Communication link should be established"),n.a.createElement("b",null,"Direct"),n.a.createElement("ul",null,n.a.createElement("li",null,"sender -",">"," receiver"),n.a.createElement("li",null,"Sender should explicitly mention receiver's address"),n.a.createElement("li",null,"A link exist between each pair")),n.a.createElement("b",null,"Indirect"),n.a.createElement("ul",null,n.a.createElement("li",null,"sender -",">"," mailbox (ports) -",">"," receiver"),n.a.createElement("li",null,"Multiple links can be present")),n.a.createElement("br",null),n.a.createElement("b",null,"Symmetric"),n.a.createElement("ul",null,n.a.createElement("li",null,"Both sender and receiver should name the other to communicate")),n.a.createElement("b",null,"Asymmetric"),n.a.createElement("ul",null,n.a.createElement("li",null,"Only sender needs to name the receiver to communicate")),n.a.createElement("br",null),n.a.createElement("b",null,"Mailbox owned by a process"),n.a.createElement("ul",null,n.a.createElement("li",null,"The owner of the mailbox can only receive"),n.a.createElement("li",null,"Mailbox disappears when process terminates")),n.a.createElement("b",null,"Mailbox owned by OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Can use the mailbox for both sending and receiving"),n.a.createElement("li",null,"OS allows processes to create, delete, send and receive messages via mailbox")),n.a.createElement("b",null,"Synchronization"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Blocking (sync.)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Blocking send : sender blocked until msg is received"),n.a.createElement("li",null,"Blocking receive : receiver blocked until msg is available"))),n.a.createElement("li",null,n.a.createElement("b",null,"Non-blocking (async.)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Non-blocking send : sender sends and continue"),n.a.createElement("li",null,"Non-blocking receive : receiver receives valid msg or null")))),"Rendezvous = when both send and receive are blocking",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Buffering : "),"messages exchanged reside on a temporary queue.",n.a.createElement("ul",null,n.a.createElement("li",null,"zero capacity : link cant have any msg waiting in it sender blocked until receiver receives"),n.a.createElement("li",null,"bounded capacity : sender blocked if full, otherwise keep on sending"),n.a.createElement("li",null,"unbounded capacity : any no. of msgs can wait in queue, sender never blocked"))),n.a.createElement("b",null,"Shared memory"),n.a.createElement("ul",null,n.a.createElement("li",null,"ProcA -",">"," shared memory -",">"," ProcB"),n.a.createElement("li",null,"Have a common buffer pool"),n.a.createElement("li",null,"Eg. Producer consumer problem (unbounded buffer, bounded buffer)")),n.a.createElement("b",null,"Communication in client server system"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Socket"),n.a.createElement("ul",null,n.a.createElement("li",null,"Socket is an endpoint of communication"),n.a.createElement("li",null,"Sockets are identified by IP address + port number"),n.a.createElement("li",null,"Sever implement specific services (telnet, ftp, http) and listens to well known ports below 1024"),n.a.createElement("li",null,"Client is assigned a port number by the host computer ",">"," 1024"),n.a.createElement("li",null,"Sockets are considered low level"),n.a.createElement("li",null,"RPC and RMI are higher level"))),n.a.createElement("li",null,n.a.createElement("b",null,"RPC"),n.a.createElement("ul",null,n.a.createElement("li",null,"Msgs are well structured, contains id of function to be executed and its parameters"),n.a.createElement("li",null,"RPC daemon(process that always runs in the background) listens to a port on remote system"),n.a.createElement("li",null,"Msgs are addressed to RPC daemon"),n.a.createElement("li",null,"Function is executed and reply is sent back in another message"),n.a.createElement("li",null,"RPC provides stub (client side proxy for actual procedure to hide the details of communication)"),n.a.createElement("li",null,"Stub locates the correct port on the server and marshalls the parameters in the correct format for transmission over network"),n.a.createElement("li",null,"Similar stub on server side which unpacks the msg and invokes the procedure and returns values"),n.a.createElement("li",null,"RPC can represent data in machine independent way using XDR (External Data Representation) Marshalling converts data from machine dependent to XDR and vice-versa"),n.a.createElement("li",null,n.a.createElement("b",null,"Binding client and server"),n.a.createElement("ul",null,n.a.createElement("li",null,"The port numbers can be fixed and therefore predetermined"),n.a.createElement("li",null,"Binding can also be done dynamically by matchmaker daemon"))),n.a.createElement("li",null,n.a.createElement("b",null,"Steps"),n.a.createElement("ol",null,n.a.createElement("li",null,"User calls kernel to send RPC msg"),n.a.createElement("li",null,"Kernel contacts matchmaker to find port number"),n.a.createElement("li",null,"Matchmaker replies to client with port number"),n.a.createElement("li",null,"Kernel sends RPC to the correct port"),n.a.createElement("li",null,"Daemon listening to port for requests and then calls specific procedure and return result"),n.a.createElement("li",null,"Kernel receives it and sends back to user"))))),n.a.createElement("li",null,n.a.createElement("b",null,"RMI"))),n.a.createElement("b",null,"Pipes : "),"it allows two processes to communicate.",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Ordinary pipe (named anonymous pipes on windows)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Allows communication only between parent and child process"),n.a.createElement("li",null,"They are unidirectional"),n.a.createElement("li",null,"Eg producer-consumer : producer writes to pipe, consumer reads from the pipe"))),n.a.createElement("li",null,n.a.createElement("b",null,"Named pipe"),n.a.createElement("ul",null,n.a.createElement("li",null,"More powerful than ordinary pipes"),n.a.createElement("li",null,"Allows communication between unrelated processes"),n.a.createElement("li",null,"Bidirectional / no parent-child relationship")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Multi threaded programming"),n.a.createElement("b",null,"Thread :")," fundamental unit of CPU utilization in multi-threaded programming",n.a.createElement("ul",null,n.a.createElement("li",null,"It is flow of control within a process"),n.a.createElement("li",null,"Multi-threaded process contains several different flows of control within the same address space"),n.a.createElement("li",null,"Lightweight process"),n.a.createElement("li",null,"A thread has its own ID, program counter, register set and stack"),n.a.createElement("li",null,"It shares code section, data section and other OS resources with threads of the same process"),n.a.createElement("li",null,"If a process has multiple threads the it can perform more than one task at a time"),n.a.createElement("li",null,"Each thread runs on separate CPU, increasing concurrency and parallelism")),n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"150px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"T1"),n.a.createElement("td",null,"T2"),n.a.createElement("td",null,"T3")),n.a.createElement("tr",null,n.a.createElement("td",null,"Registers"),n.a.createElement("td",null,"Registers"),n.a.createElement("td",null,"Registers")),n.a.createElement("tr",null,n.a.createElement("td",null,"Stack"),n.a.createElement("td",null,"Stack"),n.a.createElement("td",null,"Stack")),n.a.createElement("tr",null,n.a.createElement("td",{colSpan:"3"},"code & data & files")))),n.a.createElement("b",null,"2 types of threads"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"User level threads"),n.a.createElement("ul",null,n.a.createElement("li",null,"Visible to a programmer but not to kernel"),n.a.createElement("li",null,"Implemented by thread library/API"),n.a.createElement("li",null,"Faster to create and manage as kernel doesn;t intervene"),n.a.createElement("li",null,"Disadv: if the kernel is single threaded then any user level thread performing a blocking system call will block the entire process"))),n.a.createElement("li",null,n.a.createElement("b",null,"Kernel level threads"),n.a.createElement("ul",null,n.a.createElement("li",null,"OS kernel supports and manages it"),n.a.createElement("li",null,"Slower to create and manage"),n.a.createElement("li",null,"If kernel thread performs a blocking system call then it can schedule another thread on different core/processor")))),n.a.createElement("p",null,"Multi threading is more efficient than multi processes",n.a.createElement("br",null),"RPC generally multi-threaded",n.a.createElement("br",null),"Whenever a new request comes it creates a new thread to serve it and again listens for other requests"),n.a.createElement("b",null,"Benefits of Multi-threading"),n.a.createElement("ul",null,n.a.createElement("li",null,"Responsiveness"),n.a.createElement("li",null,"Resource sharing"),n.a.createElement("li",null,"Economy (resource sharing among processes is costly)"),n.a.createElement("li",null,"Scalability")),n.a.createElement("b",null,"Thread models"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Many to one"),n.a.createElement("ul",null,n.a.createElement("li",null,"Many user level threads mapped to one kernel thread"),n.a.createElement("li",null,"Thread management is done in user space so efficient"),n.a.createElement("li",null,"Entire process blocks if thread makes a blocking call"),n.a.createElement("li",null,"Multiple threads can't run in parallel on multiprocessors"))),n.a.createElement("li",null,n.a.createElement("b",null,"One to one"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each user thread is mapped to one kernel thread"),n.a.createElement("li",null,"More concurrency as other threads can run even if one thread makes a blocking call"),n.a.createElement("li",null,"Threads can run in parallel on multiple processors"),n.a.createElement("li",null,"Each new user level thread needs a corresponding kernel level thread (overhead, performance loss)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Many to many"),n.a.createElement("ul",null,n.a.createElement("li",null,"Many user level threads are multiplexed to a smaller/equal number of threads"),n.a.createElement("li",null,"Can run in parallel"),n.a.createElement("li",null,"Then a thread performs a blocking call, the kernel can schedule another thread for execution")))),n.a.createElement("b",null,"Thread Cancellation :")," task of terminating a thread(target thread)",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Asynchronous cancellation"),n.a.createElement("ul",null,n.a.createElement("li",null,"One thread terminates target thread"),n.a.createElement("li",null,"Target thread may not free the acquired resources"))),n.a.createElement("li",null,n.a.createElement("b",null,"Deferred cancellation"),n.a.createElement("ul",null,n.a.createElement("li",null,"Target thread can periodically check if it should terminate")))),n.a.createElement("b",null,"Signal handling : ")," notifying a process/thread that some event has occurred",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Synchronous signal"),n.a.createElement("ul",null,n.a.createElement("li",null,"Signal sent to same process/thread that caused signal generation"))),n.a.createElement("li",null,n.a.createElement("b",null,"Asynchronous signal"),n.a.createElement("ul",null,n.a.createElement("li",null,"Signal generated by an event external to a running process"))),"Every signal must be handled",n.a.createElement("ul",null,n.a.createElement("li",null,"User defined signal handler"),n.a.createElement("li",null,"Default signal handler (run by kernel)"))),n.a.createElement("b",null,"Thread pools"),n.a.createElement("ul",null,n.a.createElement("li",null,"Create a number of threads at startup and place them in a pool where they wait for work"),n.a.createElement("li",null,"When server receives a request it awakens a thread and assigns work to it"),n.a.createElement("li",null,"On completion thread returns back to the pool"),n.a.createElement("li",null,"Benefits:",n.a.createElement("ul",null,n.a.createElement("li",null,"Faster to respond to a request as no need of new thread creation"),n.a.createElement("li",null,"Thread pool limits the number of threads that can exist...no infinite growth")))),n.a.createElement("b",null,"Scheduler activation"),n.a.createElement("ul",null,n.a.createElement("li",null,"There needs to be communication between user and kernel level threads so that appropriate number of kernel level threads are allocated to the application."),n.a.createElement("li",null,"Scheduler activation provides upcalls - a communication mechanism from kernel to thread library."),n.a.createElement("li",null,"Required to maintain the correct number of kernel level threads.")))},{id:5,title:"Process Synchronization",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Process Synchronization"),n.a.createElement("hr",null),n.a.createElement("b",null,"Cooperating process"),n.a.createElement("ul",null,n.a.createElement("li",null,"One that can affect or can be affected by other processes."),n.a.createElement("li",null,"They may share logical address space (i.e. code and data), or share data through files or messages through threads."),n.a.createElement("li",null,"Concurrent access to shared data can result in inconsistencies."),n.a.createElement("li",null,"There has to be orderly execution of cooperating processes to ensure consistency.")),n.a.createElement("b",null,"Race condition : "),"when the outcome of the execution depends on the order in which data access takes place.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Critical section"),n.a.createElement("ul",null,n.a.createElement("li",null,"A segment of code in which a process maybe changing common variables, updating a table or writing a file etc."),n.a.createElement("li",null,"A section where we access the shared resource."),n.a.createElement("li",null,"Entry section : Request permission to enter the critical section"),n.a.createElement("li",null,"Critical section : Mutually exclusive in time (no other process can execute in its critical section)"),n.a.createElement("li",null,"Exit section : Follows the critical section"),n.a.createElement("li",null,"Remainder section")),n.a.createElement("b",null,"Solution to critical section problem must satisfy :"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Mutual exclusion :")," (mandatory)",n.a.createElement("ul",null,n.a.createElement("li",null,"Only one process can be in critical section."))),n.a.createElement("li",null,n.a.createElement("b",null,"Progress :")," (mandatory)",n.a.createElement("ul",null,n.a.createElement("li",null,"Only those processes which are not in the remainder section can enter the critical section and the selection of the process cannot be postponed indefinitely"),n.a.createElement("li",null,"Only those processes interested in entering into the critical section should compete for it."))),n.a.createElement("li",null,n.a.createElement("b",null,"Bounded waiting : "),"(optional)",n.a.createElement("ul",null,n.a.createElement("li",null,"There must be a bound on the number of times other processes are allowed to enter into the critical section after a process has made a request to enter in the critical section and before the request is granted.")))),n.a.createElement("b",null,"Software solution"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Using 2 turn variables"),n.a.createElement("ul",null,n.a.createElement("li",null,"Satisfies mutual exclusion"),n.a.createElement("li",null,"Does NOT satisfy progress hence faulty (because of strict aternations even if process doesn't want to enter CS)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Using flag variable - flag[2]"),n.a.createElement("ul",null,n.a.createElement("li",null,"Satisfies mutual exclusion"),n.a.createElement("li",null,"Satisfies progress (no strict alternation and interest of a process is considered)"),n.a.createElement("li",null,"But deadlock possible if context switch happens in entry section and flag become [T,T]"))),n.a.createElement("li",null,n.a.createElement("b",null,"Peterson's solution"),n.a.createElement("ul",null,n.a.createElement("li",null,"Uses both flag and turn variable"),n.a.createElement("li",null,"Satisfies all 3 conditions (mutual exclusion, progress and bounded wait)"),n.a.createElement("li",null,"Difficult to scale up to n-processes (solution is semaphores)")))),n.a.createElement("b",null,"Peterson's solution"),n.a.createElement("ul",null,n.a.createElement("li",null,"Software solution that can be used to prevent race condition"),n.a.createElement("li",null,"Two process solution"),n.a.createElement("li",null,"Assumes that LOAD and STORE instructions are atomic and cannot be interrupted"),n.a.createElement("li",null,"The 2 processes share two variables",n.a.createElement("ol",null,n.a.createElement("li",null,"int turn",n.a.createElement("ul",null,n.a.createElement("li",null,"Turn indicates whose turn it is to enter the critical section"))),n.a.createElement("li",null,"boolean flag[2]",n.a.createElement("ul",null,n.a.createElement("li",null,"Flag array is used to indicate if a process is ready to enter into the critical section"),n.a.createElement("li",null,"flag[i]=true implies process P",n.a.createElement("sub",null,"i")," is ready")))))),n.a.createElement("b",null,"Hardware solutions"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Locks"),n.a.createElement("ul",null,n.a.createElement("li",null,"Acquiring and releasing locks"),n.a.createElement("li",null,"Atomic instruction running on different CPUs will run sequentially"),n.a.createElement("li",null,n.a.createElement("b",null,"Semaphores"),n.a.createElement("ul",null,n.a.createElement("li",null,"A synchronization tool used to control access to shared variables so that only one process at any point of time change the value of the shared variable."),n.a.createElement("li",null,"A semaphore S is an integer variable that is accessed only through two standard atomic operations wait and signal.",n.a.createElement("br",null),n.a.createElement("br",null),"wait(s)"," {",n.a.createElement("br",null),"while(s","<","=0);",n.a.createElement("br",null)," s--;",n.a.createElement("br",null),"}",n.a.createElement("br",null),n.a.createElement("br",null),"signal(s)"," {",n.a.createElement("br",null),"s++;",n.a.createElement("br",null),"}"),"Two types",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Counting :")," allows n processes to access the shared resource by initializing semaphore to n n processes share the semaphore(aka mutex) initialised to 1."),n.a.createElement("li",null,n.a.createElement("b",null,"Binary :")," semaphore value only 0 or 1.")),n.a.createElement("b",null,"Mutual exclusion solution"),n.a.createElement("p",null,"do"," {",n.a.createElement("br",null),"wait(mutex);",n.a.createElement("br",null),"critical section",n.a.createElement("br",null),"signal(mutex);",n.a.createElement("br",null),"}"," while(true);"),n.a.createElement("b",null,"Disadvantage"),n.a.createElement("ul",null,n.a.createElement("li",null,"They all require busy waiting (process trying to enter critical section must loop continuously in the entry code)"),n.a.createElement("li",null,"This wastes CPU cycle"),n.a.createElement("li",null,"This type of semaphore is also called spinlock(because process spins while waiting for lock)")),n.a.createElement("b",null,"Advantage"),n.a.createElement("ul",null,n.a.createElement("li",null,"No context switch is required when a process waits for a lock (useful for short period)")))),n.a.createElement("li",null,"Implementing a semaphore with waiting queue can cause deadlock issue"),n.a.createElement("li",null,n.a.createElement("b",null,"Deadlock : "),"caused when a process in the waiting set is waiting for an event/resource held by another process in the waiting set in circular manner"),n.a.createElement("li",null,n.a.createElement("b",null,"Starvation : "),"when a process waits indefinitely within the semaphore"),n.a.createElement("li",null,n.a.createElement("b",null,"Priority Inversion : "),"when a high priority process needs data currently being accessed by lower priority process")))),n.a.createElement("b",null,"Classic problems of synchronization"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Bounded buffer problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"There is a pool of n buffers each capable of holding one item"),n.a.createElement("li",null,"Empty and full semaphores count the number of empty and full buffers"),n.a.createElement("li",null,"Mutex semaphore provide mutual exclusion for access to the buffer pool"))),n.a.createElement("li",null,n.a.createElement("b",null,"Readers-writers problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"Data is shared among number of concurrent processes"),n.a.createElement("li",null,"Readers only read the data and do not update"),n.a.createElement("li",null,"Writers can both read and write"),n.a.createElement("li",null,"Many readers can access at the same time"),n.a.createElement("li",null,"Writers need exclusive use to shared objects"),n.a.createElement("li",null,"Both reader and writer starvation possible"))),n.a.createElement("li",null,n.a.createElement("b",null,"Dining-philosopher problem"),n.a.createElement("ul",null,n.a.createElement("li",null,"5 philosopher and 5 chopsticks"),n.a.createElement("li",null,"Philosopher wither eats or thinks"),n.a.createElement("li",null,"Semaphore chopstick[5];"),n.a.createElement("li",null,"He acquires a chopstick by wait operation and releases it by signal operation"),n.a.createElement("li",null,"No two neighbours can eat together"),n.a.createElement("li",null,"Deadlock possible"),n.a.createElement("li",null,"Sol: only pick if both are available or odd one will pick left chopstick first and even one will pick right chopstick first"),n.a.createElement("li",null,"Starvation still possible"))),"Monitors is the solution for this problem"),n.a.createElement("b",null,"Monitors"),n.a.createElement("ul",null,n.a.createElement("li",null,"It is a high level abstraction that provides a convenient and effective mechanism for process synchronization"),n.a.createElement("li",null,"Only one process may be active within a monitor at a time"),n.a.createElement("li",null,"Monitors are needed because if all processes use semaphore and one process accidentally forgets to signal then all will be deadlocked"),n.a.createElement("li",null,"Monitor is a collection of procedures, variables, and data structures that are grouped together in a module/package")),n.a.createElement("b",null,"Atomicity : "),"either full operation takes place or none.",n.a.createElement("br",null),n.a.createElement("b",null,"Transaction :")," set of operations which is successful ends with commit or if failed ends with abort.",n.a.createElement("br",null),n.a.createElement("b",null,"Serializability :")," when transactions are executed serially and atomically.",n.a.createElement("br",null),n.a.createElement("br",null),"Schedule - S1",n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"150px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"T1"),n.a.createElement("td",null,"T2")),n.a.createElement("tr",null,n.a.createElement("td",null,"read()"),n.a.createElement("td",null)),n.a.createElement("tr",null,n.a.createElement("td",null,"write()"),n.a.createElement("td",null)),n.a.createElement("tr",null,n.a.createElement("td",null),n.a.createElement("td",null,"write()")),n.a.createElement("tr",null,n.a.createElement("td",null),n.a.createElement("td",null,"read()")))),n.a.createElement("p",null,n.a.createElement("b",null,"Non-serial schedule:")," transactions can overlap",n.a.createElement("br",null),"Conflict if in two overlapping operations on same data item and one is write() operation."),"Schedule - S2",n.a.createElement("table",{className:"table table-sm table-bordered",style:{textAlign:"center",width:"150px"}},n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,"T1"),n.a.createElement("td",null,"T2")),n.a.createElement("tr",null,n.a.createElement("td",null,"read()"),n.a.createElement("td",null)),n.a.createElement("tr",null,n.a.createElement("td",null,"write(A)"),n.a.createElement("td",null,"read(A)")),n.a.createElement("tr",null,n.a.createElement("td",null,"write(A)"),n.a.createElement("td",null,"read(B)")),n.a.createElement("tr",null,n.a.createElement("td",null),n.a.createElement("td",null,"write()")),n.a.createElement("tr",null,n.a.createElement("td",null),n.a.createElement("td",null,"read()")))),"If O",n.a.createElement("sub",null,"i")," and O",n.a.createElement("sub",null,"j")," are consecutive operations of different transactions (S) and do not conflict then their order can be swapped (S') without any issue.",n.a.createElement("br",null),n.a.createElement("br",null),"S becomes S' via swapping non-conflicting operations and both are equivalent then S is conflict serializable.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Log based recovery"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Write ahead log"),n.a.createElement("br",null),"each log records describe a single operation of a transaction write and has these fields:",n.a.createElement("ol",null,n.a.createElement("li",null,"Transaction name"),n.a.createElement("li",null,"Data item name (data being written)"),n.a.createElement("li",null,"Old value"),n.a.createElement("li",null,"New value")),n.a.createElement("b",null,"Disadvantage"),n.a.createElement("ul",null,n.a.createElement("li",null,"For each write operation a write on log is also required.")),n.a.createElement("b",null,"Recovery procedure"),n.a.createElement("ul",null,n.a.createElement("li",null,"undo - restore old values"),n.a.createElement("li",null,"redo - set data to new values")))),n.a.createElement("b",null,"Checkpoints"),n.a.createElement("ul",null,n.a.createElement("li",null,"Maintain checkpoints so it is easier to roll back to last checkpoint rather than going back each transaction, which is time consuming.")))},{id:6,title:"Deadlocks",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Deadlocks"),n.a.createElement("hr",null),n.a.createElement("p",null,"A deadlocked state occurs when two or more process are waiting indefinitely for an event that can be caused only by one of the waiting processes."),n.a.createElement("b",null,"Necessary conditions")," (deadlock situation can occur if all these situation hold simultaneously)",n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Mutual exclusion"),n.a.createElement("ul",null,n.a.createElement("li",null,"At least one resource should be held in non-sharable mode (i.e can be used by only one at a time)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Hold and wait"),n.a.createElement("ul",null,n.a.createElement("li",null,"A process must hold at least one resource and be waiting for another resource held by another process"))),n.a.createElement("li",null,n.a.createElement("b",null,"No pre-emption"),n.a.createElement("ul",null,n.a.createElement("li",null,"A resource can only be released voluntarily by a process"))),n.a.createElement("li",null,n.a.createElement("b",null,"Circular wait"),n.a.createElement("ul",null,n.a.createElement("li",null,"In a set of waiting processes, all are waiting for a resource held by another process in the set (in a circular fashion)"))),"All 4 conditions must hold for a deadlock to occur"),n.a.createElement("b",null,"Resource allocation graph"),n.a.createElement("ul",null,n.a.createElement("li",null,"Vertices - Pi processes (bubble) and Rj resources (square with dots denoting no. of instances)"),n.a.createElement("li",null,"Request edge Pi-",">","Rj"),n.a.createElement("li",null,"Assignment edge Ri-",">","Pj"),n.a.createElement("li",null,"If it contains no cycle then no deadlock"),n.a.createElement("li",null,"If it contains cycle then deadlock may or may not be in deadlock",n.a.createElement("ul",null,n.a.createElement("li",null,"If only one instance per resource type then deadlock"),n.a.createElement("li",null,"If several instances per resource type then possibility of deadlock")))),n.a.createElement("b",null,"3 ways of dealing with deadlock"),n.a.createElement("ol",null,n.a.createElement("li",null,"Use protocols to avoid or prevent deadlock"),n.a.createElement("li",null,"Allow system to enter deadlock then state, detect it and recover"),n.a.createElement("li",null,"Ignore the problem and pretend that it will never occur")),n.a.createElement("b",null,"Deadlock handling methods"),n.a.createElement("ul",null,n.a.createElement("li",null,"Prevention"),n.a.createElement("li",null,"Avoidance"),n.a.createElement("li",null,"Detection and recovery"),n.a.createElement("li",null,"Ignorance / ostrich algo")),n.a.createElement("b",null,"Good approaches"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Deadlock prevention : "),"make sure at least one of the 4 conditions cannot hold"),n.a.createElement("li",null,n.a.createElement("b",null,"Deadlock avoidance : "),"information about processes and the resources it requires will be given to OS in advance and OS will make smart decisions")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Deadlock prevention"),n.a.createElement("b",null,"Mutual exclusion"),n.a.createElement("ul",null,n.a.createElement("li",null,"Only for non-sharable resources and we cannot resolve mutual exclusion in such case"),n.a.createElement("li",null,"Sharable resources have no issue")),n.a.createElement("b",null,"Hold and Wait"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Do not hold :")," Process requesting a resource may not hold any resource, before requesting something it would release all held resources. efficient"),n.a.createElement("li",null,n.a.createElement("b",null,"Conservative approach :")," Process can only request resources at the start of execution and not in the middle. So all resources required should be allocated at the start itself. less efficient"),n.a.createElement("li",null,n.a.createElement("b",null,"Wait timeout :")," a process can wait only for a certain time period. after which a process must release all resources",n.a.createElement("ul",null,n.a.createElement("li",null,"Resource utilization will be low as it will remain unutilized for long periods"),n.a.createElement("li",null,"Starvation possible, a process needing several resources may have to wait long")))),n.a.createElement("b",null,"No preemption"),n.a.createElement("ul",null,n.a.createElement("li",null,"Forcefull preemption"),n.a.createElement("li",null,n.a.createElement("b",null,"Sol1:")," if a process holds some resources and requests another resource that can't be immediately allocated to it, then all resources currently held by it are implicitly released. The process is restarted only when all required resources are available."),n.a.createElement("li",null,n.a.createElement("b",null,"Sol2:")," If requested resource is not available, then check its status whether it is held by another process which is waiting. If this is the case, preempt the resources and give it to the requestor.")),n.a.createElement("b",null,"Circular wait"),n.a.createElement("ul",null,n.a.createElement("li",null,"Impose ordering of all resource types and require that each process request resources in increasing or decreasing order (any one)."),n.a.createElement("li",null,"Require that whenever a process requests an instance of resource type, it has released resources with lower number.")),n.a.createElement("b",null,"Safe state"),n.a.createElement("ul",null,n.a.createElement("li",null,"A state is safe if a system can allocate resources to each process in some order and still avoid deadlock"),n.a.createElement("li",null,"Safe sequence : if requested resource is free or requested resource by P",n.a.createElement("sub",null,"i")," is held by process P",n.a.createElement("sub",null,"j")," where j","<","i. When lower process frees then the higher processes can continue")),n.a.createElement("b",null,"Resource allocation graph algorithm"),n.a.createElement("ul",null,n.a.createElement("li",null,"Claim edge : dotted edge P",n.a.createElement("sub",null,"i"),"-",">","R",n.a.createElement("sub",null,"j")," ","representing P",n.a.createElement("sub",null,"i")," may request R",n.a.createElement("sub",null,"j")),n.a.createElement("li",null,"Request edge : when process requests a resource"),n.a.createElement("li",null,"Assignment edge : when a resource is allocated to a process"),n.a.createElement("li",null,"Resources must be claimed a priori in the system"),n.a.createElement("li",null,"Request can only be granted if converting a request edge to assignment edge does not result in the formation of a cycle in the resource allocation graph.")),n.a.createElement("b",null,"Bankers algorithm (for deadlock avoidance)"),n.a.createElement("ul",null,n.a.createElement("li",null,"First use bankers safety algorithm to check whether the system is in safe state"),n.a.createElement("li",null,"Then use the resource request algorithm to check whether each of the given requests may be safely granted or not."),n.a.createElement("li",null,"Each process has",n.a.createElement("ul",null,n.a.createElement("li",null,"Allocation vector : no. of each resource type allocated"),n.a.createElement("li",null,"Max vector : the maximum number of each resource to be used"),n.a.createElement("li",null,"Need vector : outstanding resources (max - allocation)"))),n.a.createElement("li",null,"Available/work vector : free resources over all processes"),n.a.createElement("li",null,"Maximum resource vector : allocation vectors + available vector"),n.a.createElement("li",null,"Finish vector : indicates which processes are still running"),n.a.createElement("li",null,"Disadvantages",n.a.createElement("ul",null,n.a.createElement("li",null,"It requires fixed number of resources to allocate"),n.a.createElement("li",null,"Resources may breakdown suddenly"),n.a.createElement("li",null,"Process rarely know their max resource needs in advance"),n.a.createElement("li",null,"It requires a fixed number of processes but in real life it may vary dynamically")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Deadlock detection"),n.a.createElement("ul",null,n.a.createElement("li",null,"Determines if deadlock has occurred. If occured the run recovery algorithm"),n.a.createElement("li",null,n.a.createElement("b",null,"Adv :")," process needs not to be known in advance"),n.a.createElement("li",null,n.a.createElement("b",null,"Disadv :")," detection and recovery schemes require overhead and some losses occur while recovering from deadlock")),"If single instance of each resource type",n.a.createElement("ul",null,n.a.createElement("li",null,"We maintain a wait-for graph",n.a.createElement("ul",null,n.a.createElement("li",null,"Nodes are processes"),n.a.createElement("li",null,"P",n.a.createElement("sub",null,"i"),"-",">","P",n.a.createElement("sub",null,"j")," (P",n.a.createElement("sub",null,"i")," is waiting for P",n.a.createElement("sub",null,"j"),")"),n.a.createElement("li",null,"Cycle in wait-for graph represents deadlock")))),"If several instances of a resource type",n.a.createElement("ul",null,n.a.createElement("li",null,"Wait-for graph not applicable"),n.a.createElement("li",null,"Here we use deadlock detection algorithm with specific data structure",n.a.createElement("ul",null,n.a.createElement("li",null,"Available : vector of length m indicating no. of resources of each type"),n.a.createElement("li",null,"Allocation : an n x m matrix denoting no. of resources allocated to each process"),n.a.createElement("li",null,"Request : an n x m matrix indicated the current request of each process Request[i][j]=k -",">"," P",n.a.createElement("sub",null,"i")," requests K instances of resource R",n.a.createElement("sub",null,"j"))))),"Issue is when to call and at what frequency to call the detection algorithm Recovery from deadlock.",n.a.createElement("br",null),"Once detected",n.a.createElement("ul",null,n.a.createElement("li",null,"System admin can terminate"),n.a.createElement("li",null,"Automatic termination")),n.a.createElement("b",null,"Resource preemption"),n.a.createElement("ul",null,n.a.createElement("li",null,"Selecting victim (whom to abort)"),n.a.createElement("li",null,"Rollback (go back to safe state and start again)"),n.a.createElement("li",null,"Starvation (same process is selected as victim for a long time, so it must be picked a small no. of times)")))},{id:7,title:"Memory Management",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Memory Management"),n.a.createElement("hr",null),n.a.createElement("ul",null,n.a.createElement("li",null,"Keeping track of which parts of memory are currently being used and by whom"),n.a.createElement("li",null,"Deciding which processes are to be loaded into memory if space is available"),n.a.createElement("li",null,"Allocating and deallocating memory space as needed"),n.a.createElement("li",null,"For any program to run, it must be mapped to absolute addresses and loaded into memory"),n.a.createElement("li",null,"CPU generates address for secondary memory (logical address)")),n.a.createElement("b",null,"Basic hardware"),n.a.createElement("ul",null,n.a.createElement("li",null,"Main memory and registers can only be accessed by CPU directly"),n.a.createElement("li",null,"Register access takes only one CPU cycle"),n.a.createElement("li",null,"Main memory access take many cycles"),n.a.createElement("li",null,"Cache sits between main memory and registers"),n.a.createElement("li",null,"Protection of memory required to be ensured for correct operation"),n.a.createElement("li",null,"A pair of Base and Limit registers define the logical(virtual) address space"),n.a.createElement("li",null,"Base = 300040 (address at which a process' first block resides)",n.a.createElement("br",null),"Suppose the process ends at address 420940 then,",n.a.createElement("br",null)," Limit = 420940 - 300040 = 120900 (logical address space)")),n.a.createElement("b",null,"Address binding"),n.a.createElement("ul",null,n.a.createElement("li",null,"Binding of instructions and data to memory addresses"),n.a.createElement("li",null,"Input queue : collection of processes in disk waiting to be loaded into memory for execution"),n.a.createElement("li",null,"Processes can reside in any parts of the memory"),n.a.createElement("li",null,"Addresses used in source program are symbolic"),n.a.createElement("li",null,"Compiler binds these symbolic addresses to relocatable addresses"),n.a.createElement("li",null,"Linkage editor/loader binds these relocatable addresses to absolute addresses")),n.a.createElement("b",null,"3 stages of address binding"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Compile time"),n.a.createElement("ul",null,n.a.createElement("li",null,"If memory location known apriori, absolute code can be generated"),n.a.createElement("li",null,"Recompilation required if memory location changes"))),n.a.createElement("li",null,n.a.createElement("b",null,"Load time"),n.a.createElement("ul",null,n.a.createElement("li",null,"Memory location is not known at compile time"),n.a.createElement("li",null,"It must generate relocatable addresses"))),n.a.createElement("li",null,n.a.createElement("b",null,"Execution time"),n.a.createElement("ul",null,n.a.createElement("li",null,"Binding delayed until runtime, if processes can moved in memory during execution"),n.a.createElement("li",null,"Needs hardware support (base and limit registers)")))),n.a.createElement("p",null,n.a.createElement("b",null,"Logical address :")," generated by CPU.",n.a.createElement("br",null),n.a.createElement("b",null,"Physical address :")," one seen by memory unit, and loaded into memory address register of the memory."),n.a.createElement("ul",null,n.a.createElement("li",null,"Compile time and load time address binding methods generate identical logical and physical addresses."),n.a.createElement("li",null,"Execution time address binding results in differing logical(virtual) and physical address.")),n.a.createElement("p",null,n.a.createElement("b",null,"Logical address space :")," the set of all logical addresses generated by a program pointing to locations in secondary memory.",n.a.createElement("br",null),n.a.createElement("b",null,"Physical address space :")," the set of all physical addresses corresponding to these logical addresses. Physical address points to location in main memory."),"Logical address ","<"," Limit register value otherwise trap generated.",n.a.createElement("hr",null),n.a.createElement("h4",null,"MMU (memory management unit)"),n.a.createElement("ul",null,n.a.createElement("li",null,"A hardware device that does the run-time mapping from virtual to physical addresses"),n.a.createElement("li",null,"The value in relocation(base) register is added to every address generated by user process at the time it is sent to memory"),n.a.createElement("li",null,"User program never sees the physical address, it works with logical address")),"logical address + relocation register value = physical address",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Dynamic loading"),n.a.createElement("ul",null,n.a.createElement("li",null,"Routine is not loaded until it is called"),n.a.createElement("li",null,"When executing program calls a routine, first it is checked if that routine is already loaded in memory or not. If not the relocatable linking loader is called to load the desired routine into memory"),n.a.createElement("li",null,"Adv. : unused routine is never loaded")),n.a.createElement("b",null,"Static linking"),n.a.createElement("ul",null,n.a.createElement("li",null,"System language libraries are treated like any other object module and are combined by the loader into the binary program image.")),n.a.createElement("b",null,"Dynamic linking"),n.a.createElement("ul",null,n.a.createElement("li",null,"Linking is postponed until execution")),n.a.createElement("b",null,"Stub : "),"a stub is found in the image for each library routine reference",n.a.createElement("ul",null,n.a.createElement("li",null,"It tells how to locate the library routine if already loaded"),n.a.createElement("li",null,"It tells how to load the routine if not already present in memory"),n.a.createElement("li",null,"Either way the stub replaces itself with the address of the routine and executes it"),n.a.createElement("li",null,"All the processes that use language library execute only one copy of the library code")),n.a.createElement("p",null,"Dynamic loading does not require help from OS. But, dynamic linking does require help from OS because only OS can tell if the required routine is in some other process' memory space"),n.a.createElement("b",null,"Swapping"),n.a.createElement("ul",null,n.a.createElement("li",null,"Swapping of processes in between main memory and backing store(disk)"),n.a.createElement("li",null,"Roll in, roll out : high priority process is brought into memory and lower priority process is sent back to disk"),n.a.createElement("li",null,"Overhead of transfer time")),n.a.createElement("b",null,"Protection"),n.a.createElement("ul",null,n.a.createElement("li",null,"Memory is contained of OS + user process"),n.a.createElement("li",null,"OS needs to be protected from user process"),n.a.createElement("li",null,"User process needs to be protected from other user process"),n.a.createElement("li",null,"Use relocation(base) and limit register for protection"),n.a.createElement("li",null,"Relocation register contains smallest physical address"),n.a.createElement("li",null,"Limit register contains range of logical addresses"),n.a.createElement("li",null,"When CPU scheduler selects a process for execution, the dispatcher loads the relocation and the limit registers"),n.a.createElement("li",null,"Base ","<","= allowed addresses ","<"," base + limit")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Memory allocation"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Contiguous")," (external fragmentation issue)",n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Fixed size partitioning"),n.a.createElement("ul",null,n.a.createElement("li",null,"Internal fragmentation can also happen in this approach."),n.a.createElement("li",null,"Partitions can be different size, but once fixed cannot be changed."),n.a.createElement("li",null,"Divide memory into fixed partitions"),n.a.createElement("li",null,"Each partition has one process"),n.a.createElement("li",null,"Degree of multiprogramming depends on no. of divisions"),n.a.createElement("li",null,"OS keeps a table to record which parts are free or allocated"),n.a.createElement("li",null,"Not used now"),n.a.createElement("li",null,"Best fit performs best"))),n.a.createElement("li",null,n.a.createElement("b",null,"Variable size partitioning"),n.a.createElement("ul",null,n.a.createElement("li",null,"Partitions are not made initially and can change based on process req."),n.a.createElement("li",null,"Memory is considered as one big hole"),n.a.createElement("li",null,"When new process arrives a we find a hole large enough to accommodate it"),n.a.createElement("li",null,"The process occupies only as much space as it needs"),n.a.createElement("li",null,"Worst fit performs best generally")),n.a.createElement("b",null,"Algorithms"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"First fit")," (better and faster)",n.a.createElement("ul",null,n.a.createElement("li",null,"Allocate it to first hole that is big enough"))),n.a.createElement("li",null,n.a.createElement("b",null,"Best fit"),n.a.createElement("ul",null,n.a.createElement("li",null,"Allocate to smallest hole that is big enough"))),n.a.createElement("li",null,n.a.createElement("b",null,"Worst fit")," (not as good as above two)",n.a.createElement("ul",null,n.a.createElement("li",null,"allocates to largest hole")))),"These algorithms suffer from external fragmentation")),n.a.createElement("b",null,"Fragmentation"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"External fragmentation")," (more major issue)",n.a.createElement("ul",null,n.a.createElement("li",null,"Condition when enough total memory space exists to satisfy a request, but it is not contiguous."))),n.a.createElement("li",null,n.a.createElement("b",null,"Internal fragmentation"),n.a.createElement("ul",null,n.a.createElement("li",null,"Allocated memory may be slightly larger than the requested memory, this size difference is memory internal to a partition but not being used."))),n.a.createElement("li",null,n.a.createElement("b",null,"Compaction (solution)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Free memory is combined to form contiguous large block"),n.a.createElement("li",null,"Compaction is not always possible: if relocation is static and is done at assembly / load time, compaction cannot be done (a static relocation does not allow contents of memory to change)"),n.a.createElement("li",null,"Simplest compaction algorithm"),n.a.createElement("li",null,"Move all processes towards one end of memory, leaving one large hole of free memory (expensive, lots of overhead)"),n.a.createElement("li",null,"Another solution is to permit the logical address space of a process to be non-contiguous (paging and segmentation allows this solution)"))))),n.a.createElement("li",null,n.a.createElement("b",null,"Non-contiguous"),n.a.createElement("ul",null,n.a.createElement("li",null,"Solves external fragmentation"),n.a.createElement("b",null,"Paging"),n.a.createElement("ul",null,n.a.createElement("li",null,"Paging permits the physical address space of a process to be non-contiguous"),n.a.createElement("li",null,"Traditionally support for paging has been handled by hardware"),n.a.createElement("li",null,"Recent design : the hardware and OS are closely integrated"),n.a.createElement("br",null),n.a.createElement("li",null,"Physical memory (RAM) is broken into fixed sized blocks called frames"),n.a.createElement("li",null,"Logical memory (backing store) is broken into same sized blocks called pages (processes broken down into pages)"),n.a.createElement("br",null),n.a.createElement("li",null,"When a process is to be executed, its pages are loaded into any available memory frame from the backing store"),n.a.createElement("br",null),n.a.createElement("li",null,"Noncontiguous frames are allocated to each page of the process"),n.a.createElement("li",null,"The backing store has blocks the same size as the memory frames"),n.a.createElement("li",null,"Every address generated by the CPU is divided into two parts:",n.a.createElement("ol",null,n.a.createElement("li",null,"Page number (to index the page table)"),n.a.createElement("li",null,"Page offset"))),n.a.createElement("li",null,"To generate physical address from this logical address, page table is used"),n.a.createElement("li",null,"Page table is present for every process"),n.a.createElement("li",null,"Page table contains base address of each page in memory"),n.a.createElement("li",null,"Page table entry points to the frame number in physical memory"),n.a.createElement("li",null,"An entry in page table corresponding to a page number in logical memory gives the frame number of the frame where that page is stored in physical memory (main memory)."),n.a.createElement("li",null,"Base address + offset = physical memory address"),n.a.createElement("li",null,"The page size defined by hardware is generally of size 2",n.a.createElement("sup",null,"n")),n.a.createElement("br",null),n.a.createElement("li",null,"Paging scheme has no external fragmentation, but some internal fragmentation."),n.a.createElement("li",null,"A frame table contains entries for each physical page frame, indicating which are allocated to which pages of which process."),n.a.createElement("br",null),n.a.createElement("li",null,"Hardware support : Most OSs store a page table for each process"),n.a.createElement("li",null,"A pointer to the page table is stored in the process control block"),n.a.createElement("li",null,"Page table is implemented as a set of dedicated registers"),n.a.createElement("li",null,"But it only works if size of page table is small"),n.a.createElement("li",null,"Page table is kept in memory and page table base register PTBR points to the page table"),n.a.createElement("li",null,"Two memory accesses are required to access one byte"),n.a.createElement("li",null,"To speed up this process TLB (translation lookaside buffer) is provided (TLB columns -page no., frame no.)"),n.a.createElement("li",null,"TLB is fast lookup hardware cache (page number to frame number mapping) if no match of key(page number) is found then only page table is searched"),n.a.createElement("li",null,"TLB stores info of pages of a single process, so for every context switch TLB has to be cleared"),n.a.createElement("li",null,"So many frequent context switch reduces hit ratio"),n.a.createElement("br",null),n.a.createElement("li",null,"If address if of n-bits then size of memory is 2^n * (size of location) ",n.a.createElement("br",null),"2",n.a.createElement("sup",null,"10")," - 1K, 2",n.a.createElement("sup",null,"20")," - 1M, 2",n.a.createElement("sup",null,"30")," - 1G, 2",n.a.createElement("sup",null,"40")," - 1T, 2",n.a.createElement("sup",null,"50")," - 1P"))),n.a.createElement("b",null,"Protection"),n.a.createElement("ul",null,n.a.createElement("li",null,"Memory protection is achieved by protection bits for each frame"),n.a.createElement("li",null,"These bits are kept in page table"),n.a.createElement("li",null,"Valid-invalid bit used to check if the page being accessed is within the logical address space or not"),n.a.createElement("li",null,"Illegal addresses are trapped by using the valid-invalid bit"),n.a.createElement("li",null,"Page table length register PTLR indicates the length of the page table")),n.a.createElement("b",null,"Shared pages"),n.a.createElement("ul",null,n.a.createElement("li",null,"It is possible to share common code"),n.a.createElement("li",null,"The code has to be non self modifying code"),n.a.createElement("li",null,"Each process has its own copy of registers and data storage")),n.a.createElement("b",null,"Structure of page table"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Hierarchical page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"AKA two level paging algorithm"),n.a.createElement("li",null,"Known as a forward mapped page table because address translation works from the outer page table inwards"),n.a.createElement("li",null,"outer page table -",">"," inner page table -",">"," memory"))),n.a.createElement("li",null,n.a.createElement("b",null,"Hashed page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each entry in hash table contains a linked list of elements that hash to the same location"),n.a.createElement("li",null,"Each element consists of :"," ",n.a.createElement("ol",null,n.a.createElement("li",null,"Virtual page number"),n.a.createElement("li",null,"Value of mapped page frame"),n.a.createElement("li",null,"Pointer to the next element in the linked list"))),n.a.createElement("li",null,"Clustered page table : are similar to hashed page table, except that each entry in the page table refers to several pages (useful in case of sparse address space)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Inverted page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"One entry for each real page of memory"),n.a.createElement("li",null,"Entry consists of the virtual address of the page stored in the real memory location, with information about the process that owns that page"),n.a.createElement("li",null,"This decreases memory needed to store each page table, but increases time needed to search a page (hash table can be used to address this issue)"))),n.a.createElement("b",null,"Protection"),n.a.createElement("ul",null,n.a.createElement("li",null,"Memory protection is achieved by protection bits for each frame"),n.a.createElement("li",null,"These bits are kept in page table"),n.a.createElement("li",null,"Valid-invalid bit used to check if the page being accessed is within the logical address space or not"),n.a.createElement("li",null,"Illegal addresses are trapped by using the valid-invalid bit"),n.a.createElement("li",null,"Page table length register PTLR indicates the length of the page table")),n.a.createElement("b",null,"Shared pages"),n.a.createElement("ul",null,n.a.createElement("li",null,"It is possible to share common code"),n.a.createElement("li",null,"The code has to be non self modifying code"),n.a.createElement("li",null,"Each process has its own copy of registers and data storage")),n.a.createElement("b",null,"Structure of page table"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Hierarchical page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"AKA two level paging algorithm"),n.a.createElement("li",null,"Known as a forward mapped page table because address translation works from the outer page table inwards"),n.a.createElement("li",null,"outer page table -",">"," inner page table -",">"," memory"))),n.a.createElement("li",null,n.a.createElement("b",null,"Hashed page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each entry in hash table contains a linked list of elements that hash to the same location"),n.a.createElement("li",null,"Each element consists of :"," ",n.a.createElement("ol",null,n.a.createElement("li",null,"Virtual page number"),n.a.createElement("li",null,"Value of mapped page frame"),n.a.createElement("li",null,"Pointer to the next element in the linked list"))),n.a.createElement("li",null,"Clustered page table : are similar to hashed page table, except that each entry in the page table refers to several pages (useful in case of sparse address space)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Inverted page table"),n.a.createElement("ul",null,n.a.createElement("li",null,"One entry for each real page of memory"),n.a.createElement("li",null,"Entry consists of the virtual address of the page stored in the real memory location, with information about the process that owns that page"),n.a.createElement("li",null,"This decreases memory needed to store each page table, but increases time needed to search a page (hash table can be used to address this issue)"))))),n.a.createElement("b",null,"Segmentation"),n.a.createElement("ul",null,n.a.createElement("li",null,"Memory management scheme that supports the user's view of memory"),n.a.createElement("li",null,"Logical addresses space is a collection of segments"),n.a.createElement("li",null,"Segments are main program, routines, stack, symbol table"),n.a.createElement("li",null,"The user specifies each address by a segment name (number) and an offset"),n.a.createElement("li",null,"A segment table maps two-dimensional user-defined address into one-dimensional physical address"),n.a.createElement("li",null,"Each entry of the table has a segment base and segment limit")))))},{id:8,title:"Disk Scheduling",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Disk Scheduling"),n.a.createElement("hr",null),n.a.createElement("p",null,n.a.createElement("b",null,"Disk scheduling")," : in case of multiple IO requests to different tracks, then which order this should be executed is decided by scheduling algorithm."),n.a.createElement("ul",null,n.a.createElement("li",null,"Circular disk is called platter"),n.a.createElement("li",null,"It rotates around spindle"),n.a.createElement("li",null,"R/W head is attached with disk arm"),n.a.createElement("li",null,"Disk is divided into circular tracks"),n.a.createElement("li",null,"Tracks are divided into sectors")),n.a.createElement("p",null,n.a.createElement("b",null,"Seek time :")," time required to move R/W head on to the desired track."),n.a.createElement("hr",null),n.a.createElement("h4",null,"Scheduling Algorithms"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"FCFS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Inefficient"))),n.a.createElement("li",null,n.a.createElement("b",null,"SSTF (shortest seek time first) "),n.a.createElement("ul",null,n.a.createElement("li",null,"Serves request which is closest"),n.a.createElement("li",null,"Efficient (usually optimal)"),n.a.createElement("li",null,"Tie is broken in the direction of head movement"),n.a.createElement("li",null,"Disadvantage overhead to calculate nearest required and starvation possible"))),n.a.createElement("li",null,n.a.createElement("b",null,"SCAN (elevator algorithm)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Scan starts from one end of the disk and moves to other end and services all req. in path"),n.a.createElement("li",null,"On reaching the head it changes the direction and continues"),n.a.createElement("li",null,"No starvation"),n.a.createElement("li",null,"Long wait time for just visited position is required"))),n.a.createElement("li",null,n.a.createElement("b",null,"CSCAN (circular scan)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Scan starts from one end of the disk and moves to other end and services all req. in path"),n.a.createElement("li",null,"On reaching end it reverses direction and reaches the other end NOT servicing any request"),n.a.createElement("li",null,"Then again starts at step 1"),n.a.createElement("li",null,"Provides uniform wait time"))),n.a.createElement("li",null,n.a.createElement("b",null,"LOOK"),n.a.createElement("ul",null,n.a.createElement("li",null,"Same as SCAN but instead of going to the end, it only goes to the last req and change direction"),n.a.createElement("li",null,"Better than SCAN"),n.a.createElement("li",null,"Overhead to find the last required"))),n.a.createElement("li",null,n.a.createElement("b",null,"CLOOK (circular look)"),n.a.createElement("ul",null,n.a.createElement("li",null,"LOOK + CSCAN"),n.a.createElement("li",null,"Will satisfy req. in one direction"),n.a.createElement("li",null,"Only goes to last req. and changes req and again only goes till the first req."),n.a.createElement("li",null,"More efficient and uniform wait time compared to CSCAN"),n.a.createElement("li",null,"More overhead in calculations")))))}],g=function(e){var l=e.activeNoteID,t=e.showNav,a=e.handleClick;return n.a.createElement("div",{className:"row",style:t?{width:"100%",margin:"0 auto",paddingTop:"15px"}:{width:"80%",margin:"0 auto",paddingTop:"15px"}},!t&&n.a.createElement("div",{className:"col-3",style:{borderRight:"1px solid #eee"}},n.a.createElement(h,{notes:b,activeNoteID:l,handleClick:a})),n.a.createElement("div",{className:"col"},n.a.createElement(p,{note:b[l].content})))},f=function(e){Object(o.a)(t,e);var l=Object(u.a)(t);function t(){var e;Object(c.a)(this,t);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=l.call.apply(l,[this].concat(n))).state={showResponsiveNav:!1,activeNoteID:0},e.handleClick=function(l){e.setState({activeNoteID:l})},e}return Object(s.a)(t,[{key:"resize",value:function(){var e=window.innerWidth<950;e!==this.state.showNav&&this.setState({showResponsiveNav:e})}},{key:"componentDidMount",value:function(){window.addEventListener("resize",this.resize.bind(this)),this.resize()}},{key:"componentWillUnmount",value:function(){window.removeEventListener("resize",this.resize.bind(this))}},{key:"render",value:function(){return n.a.createElement("div",null,n.a.createElement(E,{showNav:this.state.showResponsiveNav,notes:b,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}),n.a.createElement(g,{showNav:this.state.showResponsiveNav,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}))}}]),t}(a.Component);t(32);i.a.render(n.a.createElement(f,null),document.getElementById("root"))}},[[20,1,2]]]);
//# sourceMappingURL=main.cbeb04b1.chunk.js.map