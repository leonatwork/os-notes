(this["webpackJsonpos-notes"]=this["webpackJsonpos-notes"]||[]).push([[0],{20:function(e,t,l){e.exports=l(33)},32:function(e,t,l){},33:function(e,t,l){"use strict";l.r(t);var a=l(0),n=l.n(a),r=l(9),i=l.n(r),s=(l(25),l(10)),o=l(11),c=l(15),u=l(13),m=l(8),E=l(18),h=function(e){Object(c.a)(l,e);var t=Object(u.a)(l);function l(){var e;Object(s.a)(this,l);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=t.call.apply(t,[this].concat(n))).state={navExpanded:!1},e}return Object(o.a)(l,[{key:"render",value:function(){var e=this,t={backgroundColor:"rgb(156, 220, 164)"},l={color:"white",fontSize:"28px",fontFamily:"'Merienda One', cursive"};return this.props.showNav?n.a.createElement(m.a,{collapseOnSelect:!0,style:t,expand:"lg"},n.a.createElement(m.a.Brand,{style:l,href:"https://leonatwork.github.io/os-notes/"},"OS Notes"),n.a.createElement(m.a.Toggle,{"aria-controls":"basic-navbar-nav"}),n.a.createElement(m.a.Collapse,{id:"basic-navbar-nav"},n.a.createElement(E.a,{className:"mr-auto"},this.props.notes.map((function(t){var l="list-group-item";return t.id===e.props.activeNoteID&&(l+=" active-me"),n.a.createElement(E.a.Link,{key:t.id,href:"#"+t.id,className:l,onClick:function(){return e.props.handleClick(t.id)},style:{cursor:"pointer",textAlign:"center"}},t.title)}))))):n.a.createElement(m.a,{expand:"lg",style:t},n.a.createElement(m.a.Brand,{href:"https://leonatwork.github.io/os-notes/",style:l},"OS Notes"))}}]),l}(a.Component),d=function(e){var t=e.notes,l=e.activeNoteID,a=e.handleClick;return n.a.createElement("ul",{className:"list-group list-group-flush"},t.map((function(e){var t="list-group-item";return e.id===l&&(t+=" active"),n.a.createElement("li",{key:e.id,className:t,onClick:function(){return a(e.id)},style:{cursor:"pointer"}},e.title)})))},p=function(e){var t=e.note;return n.a.createElement(n.a.Fragment,null,t)},g=[{id:0,title:"Introduction",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Introduction"),n.a.createElement("hr",null),n.a.createElement("b",null,"Operating System"),n.a.createElement("ul",null,n.a.createElement("li",null,"System software that acts as an interface between user and hardware."),n.a.createElement("li",null,"OS manages computer hardware (controls and coordinates hardware among various programs and users)"),n.a.createElement("li",null,"Provides environment within which other programs can work")),n.a.createElement("b",null,"Other than kernel there are two types of softwares:"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"System SW :")," associated with OS but not part of the kernel"),n.a.createElement("li",null,n.a.createElement("b",null,"Application SW :")," includes all programs not associated with OS")),n.a.createElement("b",null,"Goals"),n.a.createElement("ul",null,n.a.createElement("li",null,"User friendly"),n.a.createElement("li",null,"Efficiency")),n.a.createElement("b",null,"Functions of OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Process management"),n.a.createElement("li",null,"Memory management"),n.a.createElement("li",null,"I/O device management"),n.a.createElement("li",null,"File management"),n.a.createElement("li",null,"Network management"),n.a.createElement("li",null,"Security and protection")),n.a.createElement("b",null,"Booting :")," starting the computer by loading the kernel",n.a.createElement("ul",null,n.a.createElement("li",null,"Initial program or bootstrap program runs at boot time. This program should be simple"),n.a.createElement("li",null,"It is stored in ROM or EEPROM and is known as firmware within the computer hardware"),n.a.createElement("li",null,"It initializes all aspects of system"),n.a.createElement("li",null,"Bootstrap must know how to load the OS. For this bootstrap must locate and load the OS kernel into memory")),n.a.createElement("b",null,"Interrupts"),n.a.createElement("ul",null,n.a.createElement("li",null,"Occurrence of an event is signaled by an interrupt from either hardware or software"),n.a.createElement("li",null,"Modern OSs are interrupt driven"),n.a.createElement("li",null,"HW trigger an interrupt by sending a signal to CPU"),n.a.createElement("li",null,"SW trigger an interrupt by executing a special operation called system call or monitor call"),n.a.createElement("li",null,"Number of interrupts are predefined. A table of pointers to interrupt routine is used to increase speed"),n.a.createElement("li",null,"This table is stored in low memory"),n.a.createElement("li",null,"Table keeps address of ISR for various devices. This array or interrupt vector is indexed by a unique device number. This number is provided with the request"),"Trap is a SW generated interrupt caused by an error/request from the program"),n.a.createElement("p",null,"CPU is connected to device via device controller. CPU and device controller can execute concurrently competing for memory cycles. Memory controller synchronizes access to memory"),n.a.createElement("b",null,"Storage structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"RAM (Main Memory)"),n.a.createElement("li",null,"Programs execute from Main memory"),n.a.createElement("li",null,"Use load and store operation"),n.a.createElement("li",null,"Load : main memory to internal registers"),n.a.createElement("li",null,"Store : internal registers to main memory"),n.a.createElement("li",null,"Instruction execution cycle (von Neumann Architecture) Fetch -",">"," ","Decode -",">"," Execute")),n.a.createElement("b",null,"Caching :")," copying information to faster storage system temporarily.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Storage hierarchy : "),"register(CMOS) -",">"," cache(SRAM) -",">"," main memory(DRAM) -",">"," disk storage/secondary memory(Magnetic disk)",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"Virtual memory :")," a technique in which a program larger than size of main memory can be executed",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("b",null,"I/O structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"Each device controller is incharge of specific kind of device"),n.a.createElement("li",null,"Device controller have buffer storage and set of special purpose registers"),n.a.createElement("ul",null,n.a.createElement("li",null,"I/O interrupts",n.a.createElement("ul",null,n.a.createElement("li",null,"Starting IO operations",n.a.createElement("ul",null,n.a.createElement("li",null,"CPU loads appropriate registers in device controller based on which dc takes action"),n.a.createElement("li",null,"Once complete the dc lets it known to CPU by triggering an interrupt"))))),n.a.createElement("li",null,"Synchronous IO",n.a.createElement("ul",null,n.a.createElement("li",null,"Control returned to IO process at IO completion"),n.a.createElement("li",null,"Till then process is moved to waiting phase"))),n.a.createElement("li",null,"Asynchronous IO",n.a.createElement("ul",null,n.a.createElement("li",null,"Control returned to IO process without waiting for IO completion"),n.a.createElement("li",null,"Device status table is used to keep track of IO devices. Table entry tells (device's type, address and state)"),n.a.createElement("li",null,"If other process requests the busy device then it is put in wait queue"),n.a.createElement("li",null,"On completion interrupt is triggered and table is updated"))))),n.a.createElement("b",null,"DMA structure"),n.a.createElement("ul",null,n.a.createElement("li",null,"Used for high speed IO devices"),n.a.createElement("li",null,"Device controller set DMA controller registers to use appropriate source and destination addresses"),n.a.createElement("li",null,"OS finds a buffer for transfer"),n.a.createElement("li",null,"The device controller transfers a block of data directly to/from its own buffer storage to memory without CPU intervention."),n.a.createElement("li",null,"CPU can perform other tasks during this"),n.a.createElement("li",null,"Once transfer is complete DMA controller interrupts the CPU")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Computer System Architecture"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Single processor system :")," 1 CPU"),n.a.createElement("li",null,n.a.createElement("b",null,"Multi processor system :")," Multiple processors sharing resources like bus, clock, memory, peripherals... Adv is graceful degradation - incase of failure some system available to respond, but some slow down occurs.",n.a.createElement("ul",null,n.a.createElement("li",null,"Tandem system : 2 identical processors (Primary+Backup) if failure backup activated"),n.a.createElement("li",null,"SMP (Symmetric Multiprocessing system) - each processor runs identical copy of OS"),n.a.createElement("li",null,"Asymmetric MP - each system assigned specific task by master"),n.a.createElement("li",null,"Cluster systems : multiple CPU on different systems coupled together. Adv...high availability")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Types of OS"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Batch processing OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Jobs with similar needs are batched together and executed through processor as a group"),n.a.createElement("li",null,"No memory hierarchy only one memory and os is present it it the whole time"),n.a.createElement("li",null,"One cpu"),n.a.createElement("li",null,"One operator who groups the job into batches"),n.a.createElement("li",null,"Slow"),n.a.createElement("li",null,"Inefficient"),n.a.createElement("li",null,"Oldest"),n.a.createElement("li",null,"Better than previous design as grouping of jobs removed the time needed for loading compiler"))),n.a.createElement("li",null,n.a.createElement("b",null,"Spooling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Simultaneous peripheral operations online"),n.a.createElement("li",null,"Additional disk memory is introduced"),n.a.createElement("li",null,"Peripheral devices interact with disk directly and not cpu"),n.a.createElement("li",null,"Cpu only deals with main memory which in turn deals with disk"),n.a.createElement("li",null,"Cpu utilization is improved"),n.a.createElement("li",null,"Multiple devices can interact with disk simultaneously"),n.a.createElement("li",null,"Interactive processes possible"),n.a.createElement("li",null,"But dis adv is it is uniprogramming ie. cpu waits if process needs for some io"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multiprogramming OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"Goal is max cpu utilization"),n.a.createElement("li",null,"Cpu doesn't wait if process waits for io, it executes another ready process available in main memory"),n.a.createElement("li",null,"Context switch between processes happens"),n.a.createElement("li",null,"More complex management/fragmentation issues/paging required"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multi tasking / time sharing / fair share / multiprogramming with round robin"),n.a.createElement("ul",null,n.a.createElement("li",null,"Multitasking is multiprogramming with time sharing"),n.a.createElement("li",null,"Only one cpu, context switch between processes happen so fast that it appears as if it is running simultaneously"),n.a.createElement("li",null,"High response time"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multiprocessing OS"),n.a.createElement("ul",null,n.a.createElement("li",null,"2 or more CPUs in a single system, sharing memory, io devices and system buses"),n.a.createElement("li",null,"Truly parallel"),n.a.createElement("li",null,"2 kinds of architecture",n.a.createElement("ul",null,n.a.createElement("li",null,"Symmetric : all CPU same, managed by a single OS"),n.a.createElement("li",null,"Asymmetric : master slave"))),n.a.createElement("li",null,"Increased throughput and reliability")))))},{id:1,title:"Process Scheduling",content:n.a.createElement("div",null,n.a.createElement("h1",null,"Process Scheduling"),n.a.createElement("hr",null),n.a.createElement("b",null,"Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Task of selecting a process from ready queue and allocating it to CPU"),n.a.createElement("li",null,"Records in the queue are generally the PCBs"),n.a.createElement("li",null,"CPU is allocated to the selected process by dispatcher")),n.a.createElement("b",null,"Process"),n.a.createElement("ul",null,n.a.createElement("li",null,"CPU bound"),n.a.createElement("li",null,"IO bound")),n.a.createElement("b",null,"Job scheduling : "),"which job to bring into memory",n.a.createElement("br",null),n.a.createElement("b",null,"CPU scheduling : "),"which job to run if several jobs are ready",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("p",null,"Process execution = CPU burst + I/O burst"),n.a.createElement("b",null,"Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Non preemptive / cooperative"),n.a.createElement("li",null,"Preemptive")),n.a.createElement("p",null,"Dispatcher is the module that gives of the CPU to the process selected by the short-term scheduler"),n.a.createElement("b",null,"Dispatcher functions"),n.a.createElement("ul",null,n.a.createElement("li",null,"Switching context"),n.a.createElement("li",null,"Switching user mode"),n.a.createElement("li",null,"Jumping to proper location in the user program to restart that program")),"Dispatcher should be extremely fast because it called every time a context switch occurs",n.a.createElement("br",null),n.a.createElement("b",null,"Dispatch latency :")," time it take for dispatcher to stop one process and start another",n.a.createElement("hr",null),n.a.createElement("h4",null,"Scheduling criteria"),n.a.createElement("ul",null,n.a.createElement("li",null,"CPU utilization"),n.a.createElement("li",null,"Throughput"),n.a.createElement("li",null,"Turn around time"),n.a.createElement("li",null,"Waiting time"),n.a.createElement("li",null,"Response time")),n.a.createElement("b",null,"Measurements"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Burst time (BT):")," time the process requires for running on CPU."),n.a.createElement("li",null,n.a.createElement("b",null,"Waiting time (WT):")," time spent by a process in ready state waiting for CPU."),n.a.createElement("li",null,n.a.createElement("b",null,"Arrival time (AT):")," time at which process arrives in ready state."),n.a.createElement("li",null,n.a.createElement("b",null,"Exit time (ET):")," when process completed its execution and exits the system."),n.a.createElement("li",null,n.a.createElement("b",null,"Turn around time (TAT):")," total time taken by a process in CPU (process submission to completion)."),n.a.createElement("li",null,n.a.createElement("b",null,"Response time :")," time between a process enters the ready queue and get scheduled on the CPU for the first time.")),n.a.createElement("p",null,"TAT = ET - AT = WT + BT"),n.a.createElement("b",null,"CPU scheduling evaluation criteria"),n.a.createElement("ul",null,n.a.createElement("li",null,"Average waiting time"),n.a.createElement("li",null,"Average response time"),n.a.createElement("li",null,"CPU utilization")),n.a.createElement("hr",null),n.a.createElement("h4",null,"Algorithms"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"FCFS (non-preemptive)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Low throughput"),n.a.createElement("li",null,n.a.createElement("b",null,"Convoy effect :")," smaller process have to wait for long time for bigger process to release CPU"),n.a.createElement("li",null,n.a.createElement("b",null,"Advantage :")," simple and easy to use/understand. must be used for background process where execution is not urgent"),n.a.createElement("li",null,n.a.createElement("b",null,"Disadvantage :")," convoy effect, normally higher average waiting time, no consideration of priority or burst time."),n.a.createElement("li",null,"Should not be used for interactive system"),n.a.createElement("li",null,"No starvation here, as processor is unbiased"))),n.a.createElement("li",null,n.a.createElement("b",null,"SJF"),n.a.createElement("ul",null,n.a.createElement("li",null,"Both preemptive SRTF and non-preemptive SJF"),n.a.createElement("li",null,"SRTF is optimal as it guarantees minimum average waiting time"),n.a.createElement("li",null,"Better average response time than FCFS"),n.a.createElement("li",null,"Cannot be implemented as we dont know burst time of a process"),n.a.createElement("li",null,"Starvation of larger burst time process and higher response time (Highest response ratio next - modification of SJF to solve this)"))),n.a.createElement("li",null,n.a.createElement("b",null,"Priority Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Both preemptive and non-preemptive"),n.a.createElement("li",null,"How priority defined:",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Internally defined : "),"use some measurable quantity to compute the priority. Eg. time limits, memory requirements, no. of open files."),n.a.createElement("li",null,n.a.createElement("b",null,"Externally defined : "),"set by criteria that are external to the OS. Eg. by user."))),n.a.createElement("li",null,"Problem of starvation : low priority process never get access of CPU"),n.a.createElement("li",null,"Solution: Aging - increasing the priority of the process that waits in the system for longer time"))),n.a.createElement("li",null,n.a.createElement("b",null,"Round Robin"),n.a.createElement("ul",null,n.a.createElement("li",null,"Designed specially for time sharing systems"),n.a.createElement("li",null,"Like FCFS with preemption"),n.a.createElement("li",null,"Time quantum/time slice (generally 10 - 100ms)"),n.a.createElement("li",null,"Ready queue is treated as a circular queue"),n.a.createElement("li",null,"In RR we need to keep in mind the time for context switching"),n.a.createElement("li",null,"If time quantum is large then it will be like FCFS"),n.a.createElement("li",null,"If time quantum is very small (compared to context switch time) then overhead"),n.a.createElement("li",null,"Time quantum must be large with respect to context switch time"),n.a.createElement("li",null,"Has higher TAT compared to SJF but better response"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multilevel Queue Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"Ready queue is partitioned into several separate queues"),n.a.createElement("li",null,"Processes are permanently assigned to one queue based on size, priority or process type."),n.a.createElement("li",null,"Each queue has its own scheduling"),n.a.createElement("li",null,"There must be scheduling among queues also i.e each queue gets a certain amount of CPU time and within that time it executes its processes."),n.a.createElement("li",null,"Scheduling between queues are mostly implemented as fixed priority preemptive scheduling (in fixed priority scheduling it will first cater to the foreground process and then serve background process)."),n.a.createElement("li",null,"Starvation possible"))),n.a.createElement("li",null,n.a.createElement("b",null,"Multilevel Feedback Queue"),n.a.createElement("ul",null,n.a.createElement("li",null,"Processes may move between queues"),n.a.createElement("li",null,"Processes with different CPU-burst characteristics are now seperated"),n.a.createElement("li",null,"If process uses too much CPU time it is pushed to lower priority queue"),n.a.createElement("li",null,"If process waits too long in lower priority queue, it is moved to higher priority queue (aging prevents starvation)")))),n.a.createElement("hr",null),n.a.createElement("h4",null,"Thread Scheduling"),n.a.createElement("ul",null,n.a.createElement("li",null,"OS schedules the kernel level threads"),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Local scheduling :")," thread library decides which thread to put onto an available light weight process."),n.a.createElement("li",null,n.a.createElement("b",null,"Global scheduling :")," kernel decides which kernel thread to run exist."))),n.a.createElement("b",null,"Contention scope"),n.a.createElement("ol",null,n.a.createElement("li",null,n.a.createElement("b",null,"Process contention scope : "),"On systems with many to many or many to one models, the thread library schedules user level threads to run on available light weight processes"),n.a.createElement("li",null,n.a.createElement("b",null,"System contention scope : "),"Process of deciding which kernel thread to run on CPU")),n.a.createElement("b",null,"Multiple processor scheduling (MPS)"),n.a.createElement("ul",null,n.a.createElement("li",null,"Multiple CPUs available, more complex"),n.a.createElement("li",null,"Homogeneous processor : each process maintains its own private queue of processes or threads"),n.a.createElement("li",null,"Load balancing to improve performance may be done"),n.a.createElement("li",null,"Asymmetric multiprocessing (master-slave)")),n.a.createElement("b",null,"Approaches to MPS"),n.a.createElement("ul",null,n.a.createElement("li",null,"We assume processors are homogeneous and have UMA-uniform memory access"),n.a.createElement("li",null,"Load sharing can occur with a common ready queue",n.a.createElement("ul",null,n.a.createElement("li",null,"Each processor is self scheduling and selects a process from the common queue"),n.a.createElement("li",null,"One processor is appointed as scheduler (master-slave)"))),n.a.createElement("li",null,"Asymmetric multiprocessing is easier than SMP because only one machine can access the data"),n.a.createElement("li",null,"But bottleneck may happen as only one is scheduling"),n.a.createElement("li",null,"Nowaday symmetric is more used")),n.a.createElement("b",null,"Processor affinity :")," migration of a process to another processor is avoided because of the cost of invalidating the process and repopulating the processor cache.",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Soft affinity :")," here OS tries to keep a process on one processor, but cannot guarantee that it will happen."),n.a.createElement("li",null,n.a.createElement("b",null,"Hard affinity :")," when OS can make a process not to migrate to other processors.")),n.a.createElement("b",null,"Load balancing : "),"attempts to keep load evenly distributed across all processors in SMP system.",n.a.createElement("br",null),"Migration approaches",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Push migration :"),"load on each processors are checked and then distributed evenly in case of any imbalance"),n.a.createElement("li",null,n.a.createElement("b",null,"Pull migration : ")," an idle processor pulls a waiting task from a busy processor")),n.a.createElement("p",null,"Multicore processors have very complicated scheduling issue"))}],b=function(e){var t=e.activeNoteID,l=e.showNav,a=e.handleClick;return n.a.createElement("div",{className:"row",style:l?{width:"100%",margin:"0 auto",paddingTop:"15px"}:{width:"80%",margin:"0 auto",paddingTop:"15px"}},!l&&n.a.createElement("div",{className:"col-3",style:{borderRight:"1px solid #eee"}},n.a.createElement(d,{notes:g,activeNoteID:t,handleClick:a})),n.a.createElement("div",{className:"col"},n.a.createElement(p,{note:g[t].content})))},y=function(e){Object(c.a)(l,e);var t=Object(u.a)(l);function l(){var e;Object(s.a)(this,l);for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return(e=t.call.apply(t,[this].concat(n))).state={showResponsiveNav:!1,activeNoteID:0},e.handleClick=function(t){e.setState({activeNoteID:t})},e}return Object(o.a)(l,[{key:"resize",value:function(){var e=window.innerWidth<950;e!==this.state.showNav&&this.setState({showResponsiveNav:e})}},{key:"componentDidMount",value:function(){window.addEventListener("resize",this.resize.bind(this)),this.resize()}},{key:"componentWillUnmount",value:function(){window.removeEventListener("resize",this.resize.bind(this))}},{key:"render",value:function(){return n.a.createElement("div",null,n.a.createElement(h,{showNav:this.state.showResponsiveNav,notes:g,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}),n.a.createElement(b,{showNav:this.state.showResponsiveNav,activeNoteID:this.state.activeNoteID,handleClick:this.handleClick}))}}]),l}(a.Component);l(32);i.a.render(n.a.createElement(y,null),document.getElementById("root"))}},[[20,1,2]]]);
//# sourceMappingURL=main.fadd914a.chunk.js.map